// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol/config.proto

package org.mozc.android.inputmethod.japanese.protobuf;

public final class ProtoConfig {
  private ProtoConfig() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface GeneralConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.config.GeneralConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     *
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     */
    boolean hasConfigVersion();
    /**
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     *
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     */
    int getConfigVersion();

    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     */
    boolean hasLastModifiedProductVersion();
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     */
    java.lang.String getLastModifiedProductVersion();
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     */
    com.google.protobuf.ByteString
        getLastModifiedProductVersionBytes();

    /**
     * <pre>
     * last modified time in UTC second
     * </pre>
     *
     * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
     */
    boolean hasLastModifiedTime();
    /**
     * <pre>
     * last modified time in UTC second
     * </pre>
     *
     * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
     */
    long getLastModifiedTime();

    /**
     * <pre>
     * These fileds are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     */
    boolean hasPlatform();
    /**
     * <pre>
     * These fileds are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     */
    java.lang.String getPlatform();
    /**
     * <pre>
     * These fileds are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     */
    com.google.protobuf.ByteString
        getPlatformBytes();

    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     */
    boolean hasUiLocale();
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     */
    java.lang.String getUiLocale();
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     */
    com.google.protobuf.ByteString
        getUiLocaleBytes();

    /**
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     *
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     */
    boolean hasUploadUsageStats();
    /**
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     *
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     */
    boolean getUploadUsageStats();
  }
  /**
   * <pre>
   *&#47;///////////////////////////////////////////////////////////
   * General config (1-9)
   * </pre>
   *
   * Protobuf type {@code mozc.config.GeneralConfig}
   */
  public  static final class GeneralConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.config.GeneralConfig)
      GeneralConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GeneralConfig.newBuilder() to construct.
    private GeneralConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GeneralConfig() {
      configVersion_ = 0;
      lastModifiedProductVersion_ = "0.0.0.0";
      lastModifiedTime_ = 0L;
      platform_ = "";
      uiLocale_ = "";
      uploadUsageStats_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private GeneralConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              configVersion_ = input.readUInt32();
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              lastModifiedProductVersion_ = bs;
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              lastModifiedTime_ = input.readUInt64();
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              platform_ = bs;
              break;
            }
            case 42: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000010;
              uiLocale_ = bs;
              break;
            }
            case 48: {
              bitField0_ |= 0x00000020;
              uploadUsageStats_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_GeneralConfig_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_GeneralConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder.class);
    }

    private int bitField0_;
    public static final int CONFIG_VERSION_FIELD_NUMBER = 1;
    private int configVersion_;
    /**
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     *
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     */
    public boolean hasConfigVersion() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     *
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     */
    public int getConfigVersion() {
      return configVersion_;
    }

    public static final int LAST_MODIFIED_PRODUCT_VERSION_FIELD_NUMBER = 2;
    private volatile java.lang.Object lastModifiedProductVersion_;
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     */
    public boolean hasLastModifiedProductVersion() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     */
    public java.lang.String getLastModifiedProductVersion() {
      java.lang.Object ref = lastModifiedProductVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          lastModifiedProductVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The product version that wrote this config
     * </pre>
     *
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     */
    public com.google.protobuf.ByteString
        getLastModifiedProductVersionBytes() {
      java.lang.Object ref = lastModifiedProductVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        lastModifiedProductVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LAST_MODIFIED_TIME_FIELD_NUMBER = 3;
    private long lastModifiedTime_;
    /**
     * <pre>
     * last modified time in UTC second
     * </pre>
     *
     * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
     */
    public boolean hasLastModifiedTime() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * last modified time in UTC second
     * </pre>
     *
     * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
     */
    public long getLastModifiedTime() {
      return lastModifiedTime_;
    }

    public static final int PLATFORM_FIELD_NUMBER = 4;
    private volatile java.lang.Object platform_;
    /**
     * <pre>
     * These fileds are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     */
    public boolean hasPlatform() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * These fileds are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     */
    public java.lang.String getPlatform() {
      java.lang.Object ref = platform_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          platform_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * These fileds are not used now
     * platform of machine that wrote this config
     * </pre>
     *
     * <code>optional string platform = 4 [default = ""];</code>
     */
    public com.google.protobuf.ByteString
        getPlatformBytes() {
      java.lang.Object ref = platform_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        platform_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int UI_LOCALE_FIELD_NUMBER = 5;
    private volatile java.lang.Object uiLocale_;
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     */
    public boolean hasUiLocale() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     */
    public java.lang.String getUiLocale() {
      java.lang.Object ref = uiLocale_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          uiLocale_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     *
     * <code>optional string ui_locale = 5 [default = ""];</code>
     */
    public com.google.protobuf.ByteString
        getUiLocaleBytes() {
      java.lang.Object ref = uiLocale_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        uiLocale_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int UPLOAD_USAGE_STATS_FIELD_NUMBER = 6;
    private boolean uploadUsageStats_;
    /**
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     *
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     */
    public boolean hasUploadUsageStats() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     *
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     */
    public boolean getUploadUsageStats() {
      return uploadUsageStats_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeUInt32(1, configVersion_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, lastModifiedProductVersion_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeUInt64(3, lastModifiedTime_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, platform_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, uiLocale_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeBool(6, uploadUsageStats_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, configVersion_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, lastModifiedProductVersion_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(3, lastModifiedTime_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, platform_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, uiLocale_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, uploadUsageStats_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig) obj;

      boolean result = true;
      result = result && (hasConfigVersion() == other.hasConfigVersion());
      if (hasConfigVersion()) {
        result = result && (getConfigVersion()
            == other.getConfigVersion());
      }
      result = result && (hasLastModifiedProductVersion() == other.hasLastModifiedProductVersion());
      if (hasLastModifiedProductVersion()) {
        result = result && getLastModifiedProductVersion()
            .equals(other.getLastModifiedProductVersion());
      }
      result = result && (hasLastModifiedTime() == other.hasLastModifiedTime());
      if (hasLastModifiedTime()) {
        result = result && (getLastModifiedTime()
            == other.getLastModifiedTime());
      }
      result = result && (hasPlatform() == other.hasPlatform());
      if (hasPlatform()) {
        result = result && getPlatform()
            .equals(other.getPlatform());
      }
      result = result && (hasUiLocale() == other.hasUiLocale());
      if (hasUiLocale()) {
        result = result && getUiLocale()
            .equals(other.getUiLocale());
      }
      result = result && (hasUploadUsageStats() == other.hasUploadUsageStats());
      if (hasUploadUsageStats()) {
        result = result && (getUploadUsageStats()
            == other.getUploadUsageStats());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasConfigVersion()) {
        hash = (37 * hash) + CONFIG_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getConfigVersion();
      }
      if (hasLastModifiedProductVersion()) {
        hash = (37 * hash) + LAST_MODIFIED_PRODUCT_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getLastModifiedProductVersion().hashCode();
      }
      if (hasLastModifiedTime()) {
        hash = (37 * hash) + LAST_MODIFIED_TIME_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getLastModifiedTime());
      }
      if (hasPlatform()) {
        hash = (37 * hash) + PLATFORM_FIELD_NUMBER;
        hash = (53 * hash) + getPlatform().hashCode();
      }
      if (hasUiLocale()) {
        hash = (37 * hash) + UI_LOCALE_FIELD_NUMBER;
        hash = (53 * hash) + getUiLocale().hashCode();
      }
      if (hasUploadUsageStats()) {
        hash = (37 * hash) + UPLOAD_USAGE_STATS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUploadUsageStats());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * General config (1-9)
     * </pre>
     *
     * Protobuf type {@code mozc.config.GeneralConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.config.GeneralConfig)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_GeneralConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_GeneralConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        configVersion_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        lastModifiedProductVersion_ = "0.0.0.0";
        bitField0_ = (bitField0_ & ~0x00000002);
        lastModifiedTime_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000004);
        platform_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        uiLocale_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        uploadUsageStats_ = false;
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_GeneralConfig_descriptor;
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance();
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.configVersion_ = configVersion_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.lastModifiedProductVersion_ = lastModifiedProductVersion_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.lastModifiedTime_ = lastModifiedTime_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.platform_ = platform_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.uiLocale_ = uiLocale_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.uploadUsageStats_ = uploadUsageStats_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance()) return this;
        if (other.hasConfigVersion()) {
          setConfigVersion(other.getConfigVersion());
        }
        if (other.hasLastModifiedProductVersion()) {
          bitField0_ |= 0x00000002;
          lastModifiedProductVersion_ = other.lastModifiedProductVersion_;
          onChanged();
        }
        if (other.hasLastModifiedTime()) {
          setLastModifiedTime(other.getLastModifiedTime());
        }
        if (other.hasPlatform()) {
          bitField0_ |= 0x00000008;
          platform_ = other.platform_;
          onChanged();
        }
        if (other.hasUiLocale()) {
          bitField0_ |= 0x00000010;
          uiLocale_ = other.uiLocale_;
          onChanged();
        }
        if (other.hasUploadUsageStats()) {
          setUploadUsageStats(other.getUploadUsageStats());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int configVersion_ ;
      /**
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       *
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       */
      public boolean hasConfigVersion() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       *
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       */
      public int getConfigVersion() {
        return configVersion_;
      }
      /**
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       *
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       */
      public Builder setConfigVersion(int value) {
        bitField0_ |= 0x00000001;
        configVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       *
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       */
      public Builder clearConfigVersion() {
        bitField0_ = (bitField0_ & ~0x00000001);
        configVersion_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object lastModifiedProductVersion_ = "0.0.0.0";
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       */
      public boolean hasLastModifiedProductVersion() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       */
      public java.lang.String getLastModifiedProductVersion() {
        java.lang.Object ref = lastModifiedProductVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            lastModifiedProductVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       */
      public com.google.protobuf.ByteString
          getLastModifiedProductVersionBytes() {
        java.lang.Object ref = lastModifiedProductVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          lastModifiedProductVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       */
      public Builder setLastModifiedProductVersion(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        lastModifiedProductVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       */
      public Builder clearLastModifiedProductVersion() {
        bitField0_ = (bitField0_ & ~0x00000002);
        lastModifiedProductVersion_ = getDefaultInstance().getLastModifiedProductVersion();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The product version that wrote this config
       * </pre>
       *
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       */
      public Builder setLastModifiedProductVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        lastModifiedProductVersion_ = value;
        onChanged();
        return this;
      }

      private long lastModifiedTime_ ;
      /**
       * <pre>
       * last modified time in UTC second
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
       */
      public boolean hasLastModifiedTime() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * last modified time in UTC second
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
       */
      public long getLastModifiedTime() {
        return lastModifiedTime_;
      }
      /**
       * <pre>
       * last modified time in UTC second
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
       */
      public Builder setLastModifiedTime(long value) {
        bitField0_ |= 0x00000004;
        lastModifiedTime_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * last modified time in UTC second
       * </pre>
       *
       * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
       */
      public Builder clearLastModifiedTime() {
        bitField0_ = (bitField0_ & ~0x00000004);
        lastModifiedTime_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object platform_ = "";
      /**
       * <pre>
       * These fileds are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       */
      public boolean hasPlatform() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * These fileds are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       */
      public java.lang.String getPlatform() {
        java.lang.Object ref = platform_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            platform_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * These fileds are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       */
      public com.google.protobuf.ByteString
          getPlatformBytes() {
        java.lang.Object ref = platform_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          platform_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * These fileds are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       */
      public Builder setPlatform(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        platform_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * These fileds are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       */
      public Builder clearPlatform() {
        bitField0_ = (bitField0_ & ~0x00000008);
        platform_ = getDefaultInstance().getPlatform();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * These fileds are not used now
       * platform of machine that wrote this config
       * </pre>
       *
       * <code>optional string platform = 4 [default = ""];</code>
       */
      public Builder setPlatformBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        platform_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object uiLocale_ = "";
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       */
      public boolean hasUiLocale() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       */
      public java.lang.String getUiLocale() {
        java.lang.Object ref = uiLocale_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            uiLocale_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       */
      public com.google.protobuf.ByteString
          getUiLocaleBytes() {
        java.lang.Object ref = uiLocale_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          uiLocale_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       */
      public Builder setUiLocale(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        uiLocale_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       */
      public Builder clearUiLocale() {
        bitField0_ = (bitField0_ & ~0x00000010);
        uiLocale_ = getDefaultInstance().getUiLocale();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       *
       * <code>optional string ui_locale = 5 [default = ""];</code>
       */
      public Builder setUiLocaleBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        uiLocale_ = value;
        onChanged();
        return this;
      }

      private boolean uploadUsageStats_ ;
      /**
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       *
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       */
      public boolean hasUploadUsageStats() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       *
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       */
      public boolean getUploadUsageStats() {
        return uploadUsageStats_;
      }
      /**
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       *
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       */
      public Builder setUploadUsageStats(boolean value) {
        bitField0_ |= 0x00000020;
        uploadUsageStats_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       *
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       */
      public Builder clearUploadUsageStats() {
        bitField0_ = (bitField0_ & ~0x00000020);
        uploadUsageStats_ = false;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.config.GeneralConfig)
    }

    // @@protoc_insertion_point(class_scope:mozc.config.GeneralConfig)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<GeneralConfig>
        PARSER = new com.google.protobuf.AbstractParser<GeneralConfig>() {
      public GeneralConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new GeneralConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<GeneralConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GeneralConfig> getParserForType() {
      return PARSER;
    }

    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:mozc.config.Config)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     */
    boolean hasGeneralConfig();
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getGeneralConfig();
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder getGeneralConfigOrBuilder();

    /**
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     *
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     */
    boolean hasVerboseLevel();
    /**
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     *
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     */
    int getVerboseLevel();

    /**
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * </pre>
     *
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     */
    boolean hasIncognitoMode();
    /**
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * </pre>
     *
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     */
    boolean getIncognitoMode();

    /**
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     *
     * <code>optional bool check_default = 22 [default = true];</code>
     */
    boolean hasCheckDefault();
    /**
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     *
     * <code>optional bool check_default = 22 [default = true];</code>
     */
    boolean getCheckDefault();

    /**
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     *
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     */
    boolean hasPresentationMode();
    /**
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     *
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     */
    boolean getPresentationMode();

    /**
     * <pre>
     * Roman/Kana
     * </pre>
     *
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     */
    boolean hasPreeditMethod();
    /**
     * <pre>
     * Roman/Kana
     * </pre>
     *
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod getPreeditMethod();

    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     */
    boolean hasSessionKeymap();
    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getSessionKeymap();

    /**
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     *
     * <code>optional bytes custom_keymap_table = 42;</code>
     */
    boolean hasCustomKeymapTable();
    /**
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     *
     * <code>optional bytes custom_keymap_table = 42;</code>
     */
    com.google.protobuf.ByteString getCustomKeymapTable();

    /**
     * <pre>
     * custom roman table
     * </pre>
     *
     * <code>optional bytes custom_roman_table = 43;</code>
     */
    boolean hasCustomRomanTable();
    /**
     * <pre>
     * custom roman table
     * </pre>
     *
     * <code>optional bytes custom_roman_table = 43;</code>
     */
    com.google.protobuf.ByteString getCustomRomanTable();

    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
     */
    boolean hasPunctuationMethod();
    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod getPunctuationMethod();

    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     */
    boolean hasSymbolMethod();
    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod getSymbolMethod();

    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     */
    boolean hasSpaceCharacterForm();
    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm getSpaceCharacterForm();

    /**
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     *
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     */
    boolean hasUseKeyboardToChangePreeditMethod();
    /**
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     *
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     */
    boolean getUseKeyboardToChangePreeditMethod();

    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     */
    boolean hasHistoryLearningLevel();
    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel getHistoryLearningLevel();

    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     */
    boolean hasSelectionShortcut();
    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut getSelectionShortcut();

    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> 
        getCharacterFormRulesList();
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getCharacterFormRules(int index);
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    int getCharacterFormRulesCount();
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> 
        getCharacterFormRulesOrBuilderList();
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder getCharacterFormRulesOrBuilder(
        int index);

    /**
     * <pre>
     * auto IME turn off feature
     * </pre>
     *
     * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
     */
    boolean hasUseAutoImeTurnOff();
    /**
     * <pre>
     * auto IME turn off feature
     * </pre>
     *
     * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
     */
    boolean getUseAutoImeTurnOff();

    /**
     * <pre>
     * Toggle to use cascanding window for debuging.
     * </pre>
     *
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     */
    boolean hasUseCascadingWindow();
    /**
     * <pre>
     * Toggle to use cascanding window for debuging.
     * </pre>
     *
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     */
    boolean getUseCascadingWindow();

    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     */
    boolean hasShiftKeyModeSwitch();
    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch getShiftKeyModeSwitch();

    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     */
    boolean hasNumpadCharacterForm();
    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm getNumpadCharacterForm();

    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     */
    boolean hasUseAutoConversion();
    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     */
    boolean getUseAutoConversion();

    /**
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     *
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     */
    boolean hasAutoConversionKey();
    /**
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     *
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     */
    int getAutoConversionKey();

    /**
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     *
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     */
    boolean hasYenSignCharacter();
    /**
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     *
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter getYenSignCharacter();

    /**
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     *
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     */
    boolean hasUseJapaneseLayout();
    /**
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     *
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     */
    boolean getUseJapaneseLayout();

    /**
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     *
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     */
    boolean hasUseKanaModifierInsensitiveConversion();
    /**
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     *
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     */
    boolean getUseKanaModifierInsensitiveConversion();

    /**
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     *
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     */
    boolean hasUseTypingCorrection();
    /**
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     *
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     */
    boolean getUseTypingCorrection();

    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Dictionary (80-99)
     * </pre>
     *
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     */
    boolean hasUseDateConversion();
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Dictionary (80-99)
     * </pre>
     *
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     */
    boolean getUseDateConversion();

    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     */
    boolean hasUseSingleKanjiConversion();
    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     */
    boolean getUseSingleKanjiConversion();

    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     */
    boolean hasUseSymbolConversion();
    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     */
    boolean getUseSymbolConversion();

    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     */
    boolean hasUseNumberConversion();
    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     */
    boolean getUseNumberConversion();

    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     */
    boolean hasUseEmoticonConversion();
    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     */
    boolean getUseEmoticonConversion();

    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     */
    boolean hasUseCalculator();
    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     */
    boolean getUseCalculator();

    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     */
    boolean hasUseT13NConversion();
    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     */
    boolean getUseT13NConversion();

    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     */
    boolean hasUseZipCodeConversion();
    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     */
    boolean getUseZipCodeConversion();

    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     */
    boolean hasUseSpellingCorrection();
    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     */
    boolean getUseSpellingCorrection();

    /**
     * <pre>
     * If use_emoji_conversion is true, the user can input emoji characters
     * by converting from a query string (e.g. "  " [U+1F436]).
     * Even if it is false, users might be able to input emoji characters
     * with other ways.
     * Note: Some characters can be either of text and emoji.  It would be ideal
     * to use the variation sequence to specify emoji presentation [U+FE0E],
     * although it is not implemented yet.
     * See: http://unicode.org/reports/tr51/#Presentation_Style
     * </pre>
     *
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     */
    boolean hasUseEmojiConversion();
    /**
     * <pre>
     * If use_emoji_conversion is true, the user can input emoji characters
     * by converting from a query string (e.g. "  " [U+1F436]).
     * Even if it is false, users might be able to input emoji characters
     * with other ways.
     * Note: Some characters can be either of text and emoji.  It would be ideal
     * to use the variation sequence to specify emoji presentation [U+FE0E],
     * although it is not implemented yet.
     * See: http://unicode.org/reports/tr51/#Presentation_Style
     * </pre>
     *
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     */
    boolean getUseEmojiConversion();

    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    boolean hasInformationListConfig();
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getInformationListConfig();
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder getInformationListConfigOrBuilder();

    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Suggest (100-119)
     * Use history-based suggest feature.
     * </pre>
     *
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     */
    boolean hasUseHistorySuggest();
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Suggest (100-119)
     * Use history-based suggest feature.
     * </pre>
     *
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     */
    boolean getUseHistorySuggest();

    /**
     * <pre>
     * Use dictionary-based suggest feature.
     * </pre>
     *
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     */
    boolean hasUseDictionarySuggest();
    /**
     * <pre>
     * Use dictionary-based suggest feature.
     * </pre>
     *
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     */
    boolean getUseDictionarySuggest();

    /**
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     *
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     */
    boolean hasUseRealtimeConversion();
    /**
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     *
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     */
    boolean getUseRealtimeConversion();

    /**
     * <pre>
     * Size of suggestions.
     * </pre>
     *
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     */
    boolean hasSuggestionsSize();
    /**
     * <pre>
     * Size of suggestions.
     * </pre>
     *
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     */
    int getSuggestionsSize();

    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Renderer (120-139)
     * Use mode indicator feature.
     * </pre>
     *
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     */
    boolean hasUseModeIndicator();
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Renderer (120-139)
     * Use mode indicator feature.
     * </pre>
     *
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     */
    boolean getUseModeIndicator();

    /**
     * <pre>
     * Allow the cloud handwriting.  The handwriting UI has to notice
     * user before activating the feature, and set this field to true
     * when the user permit.
     * NOTE: OSS version does not handle this field.
     * </pre>
     *
     * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
     */
    boolean hasAllowCloudHandwriting();
    /**
     * <pre>
     * Allow the cloud handwriting.  The handwriting UI has to notice
     * user before activating the feature, and set this field to true
     * when the user permit.
     * NOTE: OSS version does not handle this field.
     * </pre>
     *
     * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
     */
    boolean getAllowCloudHandwriting();
  }
  /**
   * Protobuf type {@code mozc.config.Config}
   */
  public  static final class Config extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:mozc.config.Config)
      ConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Config.newBuilder() to construct.
    private Config(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Config() {
      verboseLevel_ = 0;
      incognitoMode_ = false;
      checkDefault_ = true;
      presentationMode_ = false;
      preeditMethod_ = 0;
      sessionKeymap_ = -1;
      customKeymapTable_ = com.google.protobuf.ByteString.EMPTY;
      customRomanTable_ = com.google.protobuf.ByteString.EMPTY;
      punctuationMethod_ = 0;
      symbolMethod_ = 0;
      spaceCharacterForm_ = 0;
      useKeyboardToChangePreeditMethod_ = false;
      historyLearningLevel_ = 0;
      selectionShortcut_ = 1;
      characterFormRules_ = java.util.Collections.emptyList();
      useAutoImeTurnOff_ = true;
      useCascadingWindow_ = true;
      shiftKeyModeSwitch_ = 1;
      numpadCharacterForm_ = 2;
      useAutoConversion_ = false;
      autoConversionKey_ = 13;
      yenSignCharacter_ = 0;
      useJapaneseLayout_ = false;
      useKanaModifierInsensitiveConversion_ = false;
      useTypingCorrection_ = false;
      useDateConversion_ = true;
      useSingleKanjiConversion_ = true;
      useSymbolConversion_ = true;
      useNumberConversion_ = true;
      useEmoticonConversion_ = true;
      useCalculator_ = true;
      useT13NConversion_ = true;
      useZipCodeConversion_ = true;
      useSpellingCorrection_ = true;
      useEmojiConversion_ = false;
      useHistorySuggest_ = true;
      useDictionarySuggest_ = true;
      useRealtimeConversion_ = true;
      suggestionsSize_ = 3;
      useModeIndicator_ = true;
      allowCloudHandwriting_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Config(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      int mutable_bitField1_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = generalConfig_.toBuilder();
              }
              generalConfig_ = input.readMessage(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(generalConfig_);
                generalConfig_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 80: {
              bitField0_ |= 0x00000002;
              verboseLevel_ = input.readInt32();
              break;
            }
            case 160: {
              bitField0_ |= 0x00000004;
              incognitoMode_ = input.readBool();
              break;
            }
            case 176: {
              bitField0_ |= 0x00000008;
              checkDefault_ = input.readBool();
              break;
            }
            case 184: {
              bitField0_ |= 0x00000010;
              presentationMode_ = input.readBool();
              break;
            }
            case 320: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(40, rawValue);
              } else {
                bitField0_ |= 0x00000020;
                preeditMethod_ = rawValue;
              }
              break;
            }
            case 328: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(41, rawValue);
              } else {
                bitField0_ |= 0x00000040;
                sessionKeymap_ = rawValue;
              }
              break;
            }
            case 338: {
              bitField0_ |= 0x00000080;
              customKeymapTable_ = input.readBytes();
              break;
            }
            case 346: {
              bitField0_ |= 0x00000100;
              customRomanTable_ = input.readBytes();
              break;
            }
            case 360: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(45, rawValue);
              } else {
                bitField0_ |= 0x00000200;
                punctuationMethod_ = rawValue;
              }
              break;
            }
            case 368: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(46, rawValue);
              } else {
                bitField0_ |= 0x00000400;
                symbolMethod_ = rawValue;
              }
              break;
            }
            case 376: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(47, rawValue);
              } else {
                bitField0_ |= 0x00000800;
                spaceCharacterForm_ = rawValue;
              }
              break;
            }
            case 384: {
              bitField0_ |= 0x00001000;
              useKeyboardToChangePreeditMethod_ = input.readBool();
              break;
            }
            case 400: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(50, rawValue);
              } else {
                bitField0_ |= 0x00002000;
                historyLearningLevel_ = rawValue;
              }
              break;
            }
            case 416: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(52, rawValue);
              } else {
                bitField0_ |= 0x00004000;
                selectionShortcut_ = rawValue;
              }
              break;
            }
            case 434: {
              if (!((mutable_bitField0_ & 0x00008000) == 0x00008000)) {
                characterFormRules_ = new java.util.ArrayList<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule>();
                mutable_bitField0_ |= 0x00008000;
              }
              characterFormRules_.add(
                  input.readMessage(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.PARSER, extensionRegistry));
              break;
            }
            case 448: {
              bitField0_ |= 0x00008000;
              useAutoImeTurnOff_ = input.readBool();
              break;
            }
            case 464: {
              bitField0_ |= 0x00010000;
              useCascadingWindow_ = input.readBool();
              break;
            }
            case 472: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(59, rawValue);
              } else {
                bitField0_ |= 0x00020000;
                shiftKeyModeSwitch_ = rawValue;
              }
              break;
            }
            case 480: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(60, rawValue);
              } else {
                bitField0_ |= 0x00040000;
                numpadCharacterForm_ = rawValue;
              }
              break;
            }
            case 488: {
              bitField0_ |= 0x00080000;
              useAutoConversion_ = input.readBool();
              break;
            }
            case 496: {
              bitField0_ |= 0x00100000;
              autoConversionKey_ = input.readUInt32();
              break;
            }
            case 504: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(63, rawValue);
              } else {
                bitField0_ |= 0x00200000;
                yenSignCharacter_ = rawValue;
              }
              break;
            }
            case 512: {
              bitField0_ |= 0x00400000;
              useJapaneseLayout_ = input.readBool();
              break;
            }
            case 520: {
              bitField0_ |= 0x00800000;
              useKanaModifierInsensitiveConversion_ = input.readBool();
              break;
            }
            case 528: {
              bitField0_ |= 0x01000000;
              useTypingCorrection_ = input.readBool();
              break;
            }
            case 640: {
              bitField0_ |= 0x02000000;
              useDateConversion_ = input.readBool();
              break;
            }
            case 648: {
              bitField0_ |= 0x04000000;
              useSingleKanjiConversion_ = input.readBool();
              break;
            }
            case 656: {
              bitField0_ |= 0x08000000;
              useSymbolConversion_ = input.readBool();
              break;
            }
            case 664: {
              bitField0_ |= 0x10000000;
              useNumberConversion_ = input.readBool();
              break;
            }
            case 672: {
              bitField0_ |= 0x20000000;
              useEmoticonConversion_ = input.readBool();
              break;
            }
            case 680: {
              bitField0_ |= 0x40000000;
              useCalculator_ = input.readBool();
              break;
            }
            case 688: {
              bitField0_ |= 0x80000000;
              useT13NConversion_ = input.readBool();
              break;
            }
            case 696: {
              bitField1_ |= 0x00000001;
              useZipCodeConversion_ = input.readBool();
              break;
            }
            case 704: {
              bitField1_ |= 0x00000002;
              useSpellingCorrection_ = input.readBool();
              break;
            }
            case 712: {
              bitField1_ |= 0x00000004;
              useEmojiConversion_ = input.readBool();
              break;
            }
            case 722: {
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder subBuilder = null;
              if (((bitField1_ & 0x00000008) == 0x00000008)) {
                subBuilder = informationListConfig_.toBuilder();
              }
              informationListConfig_ = input.readMessage(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(informationListConfig_);
                informationListConfig_ = subBuilder.buildPartial();
              }
              bitField1_ |= 0x00000008;
              break;
            }
            case 800: {
              bitField1_ |= 0x00000010;
              useHistorySuggest_ = input.readBool();
              break;
            }
            case 808: {
              bitField1_ |= 0x00000020;
              useDictionarySuggest_ = input.readBool();
              break;
            }
            case 816: {
              bitField1_ |= 0x00000040;
              useRealtimeConversion_ = input.readBool();
              break;
            }
            case 880: {
              bitField1_ |= 0x00000080;
              suggestionsSize_ = input.readUInt32();
              break;
            }
            case 960: {
              bitField1_ |= 0x00000100;
              useModeIndicator_ = input.readBool();
              break;
            }
            case 2408: {
              bitField1_ |= 0x00000200;
              allowCloudHandwriting_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00008000) == 0x00008000)) {
          characterFormRules_ = java.util.Collections.unmodifiableList(characterFormRules_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder.class);
    }

    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Basic features (40-79)
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.PreeditMethod}
     */
    public enum PreeditMethod
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>ROMAN = 0;</code>
       */
      ROMAN(0),
      /**
       * <code>KANA = 1;</code>
       */
      KANA(1),
      ;

      /**
       * <code>ROMAN = 0;</code>
       */
      public static final int ROMAN_VALUE = 0;
      /**
       * <code>KANA = 1;</code>
       */
      public static final int KANA_VALUE = 1;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static PreeditMethod valueOf(int value) {
        return forNumber(value);
      }

      public static PreeditMethod forNumber(int value) {
        switch (value) {
          case 0: return ROMAN;
          case 1: return KANA;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<PreeditMethod>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          PreeditMethod> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<PreeditMethod>() {
              public PreeditMethod findValueByNumber(int number) {
                return PreeditMethod.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(0);
      }

      private static final PreeditMethod[] VALUES = values();

      public static PreeditMethod valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private PreeditMethod(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.PreeditMethod)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.SessionKeymap}
     */
    public enum SessionKeymap
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * If NONE is selected, it will be replaced with MSIME or KOTOERI.
       * NONE is used only for a placeholder, so a configuration program
       * should not show NONE as one of selections.  NONE should be the
       * last of the items due to the limitation of the Qt GUI's
       * implementation. Note that keymap number should be correspoinding
       * to the index of QComboBox in config dialog. Since NONE is not
       * used, we set -1 here.
       * </pre>
       *
       * <code>NONE = -1;</code>
       */
      NONE(-1),
      /**
       * <code>CUSTOM = 0;</code>
       */
      CUSTOM(0),
      /**
       * <code>ATOK = 1;</code>
       */
      ATOK(1),
      /**
       * <code>MSIME = 2;</code>
       */
      MSIME(2),
      /**
       * <code>KOTOERI = 3;</code>
       */
      KOTOERI(3),
      /**
       * <code>MOBILE = 4;</code>
       */
      MOBILE(4),
      /**
       * <code>CHROMEOS = 5;</code>
       */
      CHROMEOS(5),
      ;

      /**
       * <pre>
       * If NONE is selected, it will be replaced with MSIME or KOTOERI.
       * NONE is used only for a placeholder, so a configuration program
       * should not show NONE as one of selections.  NONE should be the
       * last of the items due to the limitation of the Qt GUI's
       * implementation. Note that keymap number should be correspoinding
       * to the index of QComboBox in config dialog. Since NONE is not
       * used, we set -1 here.
       * </pre>
       *
       * <code>NONE = -1;</code>
       */
      public static final int NONE_VALUE = -1;
      /**
       * <code>CUSTOM = 0;</code>
       */
      public static final int CUSTOM_VALUE = 0;
      /**
       * <code>ATOK = 1;</code>
       */
      public static final int ATOK_VALUE = 1;
      /**
       * <code>MSIME = 2;</code>
       */
      public static final int MSIME_VALUE = 2;
      /**
       * <code>KOTOERI = 3;</code>
       */
      public static final int KOTOERI_VALUE = 3;
      /**
       * <code>MOBILE = 4;</code>
       */
      public static final int MOBILE_VALUE = 4;
      /**
       * <code>CHROMEOS = 5;</code>
       */
      public static final int CHROMEOS_VALUE = 5;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SessionKeymap valueOf(int value) {
        return forNumber(value);
      }

      public static SessionKeymap forNumber(int value) {
        switch (value) {
          case -1: return NONE;
          case 0: return CUSTOM;
          case 1: return ATOK;
          case 2: return MSIME;
          case 3: return KOTOERI;
          case 4: return MOBILE;
          case 5: return CHROMEOS;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SessionKeymap>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SessionKeymap> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SessionKeymap>() {
              public SessionKeymap findValueByNumber(int number) {
                return SessionKeymap.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(1);
      }

      private static final SessionKeymap[] VALUES = values();

      public static SessionKeymap valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private SessionKeymap(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.SessionKeymap)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.PunctuationMethod}
     */
    public enum PunctuationMethod
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>KUTEN_TOUTEN = 0;</code>
       */
      KUTEN_TOUTEN(0),
      /**
       * <code>COMMA_PERIOD = 1;</code>
       */
      COMMA_PERIOD(1),
      /**
       * <code>KUTEN_PERIOD = 2;</code>
       */
      KUTEN_PERIOD(2),
      /**
       * <code>COMMA_TOUTEN = 3;</code>
       */
      COMMA_TOUTEN(3),
      ;

      /**
       * <code>KUTEN_TOUTEN = 0;</code>
       */
      public static final int KUTEN_TOUTEN_VALUE = 0;
      /**
       * <code>COMMA_PERIOD = 1;</code>
       */
      public static final int COMMA_PERIOD_VALUE = 1;
      /**
       * <code>KUTEN_PERIOD = 2;</code>
       */
      public static final int KUTEN_PERIOD_VALUE = 2;
      /**
       * <code>COMMA_TOUTEN = 3;</code>
       */
      public static final int COMMA_TOUTEN_VALUE = 3;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static PunctuationMethod valueOf(int value) {
        return forNumber(value);
      }

      public static PunctuationMethod forNumber(int value) {
        switch (value) {
          case 0: return KUTEN_TOUTEN;
          case 1: return COMMA_PERIOD;
          case 2: return KUTEN_PERIOD;
          case 3: return COMMA_TOUTEN;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<PunctuationMethod>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          PunctuationMethod> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<PunctuationMethod>() {
              public PunctuationMethod findValueByNumber(int number) {
                return PunctuationMethod.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(2);
      }

      private static final PunctuationMethod[] VALUES = values();

      public static PunctuationMethod valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private PunctuationMethod(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.PunctuationMethod)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.SymbolMethod}
     */
    public enum SymbolMethod
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>CORNER_BRACKET_MIDDLE_DOT = 0;</code>
       */
      CORNER_BRACKET_MIDDLE_DOT(0),
      /**
       * <code>SQUARE_BRACKET_SLASH = 1;</code>
       */
      SQUARE_BRACKET_SLASH(1),
      /**
       * <code>CORNER_BRACKET_SLASH = 2;</code>
       */
      CORNER_BRACKET_SLASH(2),
      /**
       * <code>SQUARE_BRACKET_MIDDLE_DOT = 3;</code>
       */
      SQUARE_BRACKET_MIDDLE_DOT(3),
      ;

      /**
       * <code>CORNER_BRACKET_MIDDLE_DOT = 0;</code>
       */
      public static final int CORNER_BRACKET_MIDDLE_DOT_VALUE = 0;
      /**
       * <code>SQUARE_BRACKET_SLASH = 1;</code>
       */
      public static final int SQUARE_BRACKET_SLASH_VALUE = 1;
      /**
       * <code>CORNER_BRACKET_SLASH = 2;</code>
       */
      public static final int CORNER_BRACKET_SLASH_VALUE = 2;
      /**
       * <code>SQUARE_BRACKET_MIDDLE_DOT = 3;</code>
       */
      public static final int SQUARE_BRACKET_MIDDLE_DOT_VALUE = 3;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SymbolMethod valueOf(int value) {
        return forNumber(value);
      }

      public static SymbolMethod forNumber(int value) {
        switch (value) {
          case 0: return CORNER_BRACKET_MIDDLE_DOT;
          case 1: return SQUARE_BRACKET_SLASH;
          case 2: return CORNER_BRACKET_SLASH;
          case 3: return SQUARE_BRACKET_MIDDLE_DOT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SymbolMethod>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SymbolMethod> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SymbolMethod>() {
              public SymbolMethod findValueByNumber(int number) {
                return SymbolMethod.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(3);
      }

      private static final SymbolMethod[] VALUES = values();

      public static SymbolMethod valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private SymbolMethod(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.SymbolMethod)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.FundamentalCharacterForm}
     */
    public enum FundamentalCharacterForm
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * follow the input mode
       * </pre>
       *
       * <code>FUNDAMENTAL_INPUT_MODE = 0;</code>
       */
      FUNDAMENTAL_INPUT_MODE(0),
      /**
       * <pre>
       * always FullWidth
       * </pre>
       *
       * <code>FUNDAMENTAL_FULL_WIDTH = 1;</code>
       */
      FUNDAMENTAL_FULL_WIDTH(1),
      /**
       * <pre>
       * always HalfWidth
       * </pre>
       *
       * <code>FUNDAMENTAL_HALF_WIDTH = 2;</code>
       */
      FUNDAMENTAL_HALF_WIDTH(2),
      ;

      /**
       * <pre>
       * follow the input mode
       * </pre>
       *
       * <code>FUNDAMENTAL_INPUT_MODE = 0;</code>
       */
      public static final int FUNDAMENTAL_INPUT_MODE_VALUE = 0;
      /**
       * <pre>
       * always FullWidth
       * </pre>
       *
       * <code>FUNDAMENTAL_FULL_WIDTH = 1;</code>
       */
      public static final int FUNDAMENTAL_FULL_WIDTH_VALUE = 1;
      /**
       * <pre>
       * always HalfWidth
       * </pre>
       *
       * <code>FUNDAMENTAL_HALF_WIDTH = 2;</code>
       */
      public static final int FUNDAMENTAL_HALF_WIDTH_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static FundamentalCharacterForm valueOf(int value) {
        return forNumber(value);
      }

      public static FundamentalCharacterForm forNumber(int value) {
        switch (value) {
          case 0: return FUNDAMENTAL_INPUT_MODE;
          case 1: return FUNDAMENTAL_FULL_WIDTH;
          case 2: return FUNDAMENTAL_HALF_WIDTH;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<FundamentalCharacterForm>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          FundamentalCharacterForm> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<FundamentalCharacterForm>() {
              public FundamentalCharacterForm findValueByNumber(int number) {
                return FundamentalCharacterForm.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(4);
      }

      private static final FundamentalCharacterForm[] VALUES = values();

      public static FundamentalCharacterForm valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private FundamentalCharacterForm(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.FundamentalCharacterForm)
    }

    /**
     * <pre>
     * User history learning
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.HistoryLearningLevel}
     */
    public enum HistoryLearningLevel
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>DEFAULT_HISTORY = 0;</code>
       */
      DEFAULT_HISTORY(0),
      /**
       * <code>READ_ONLY = 1;</code>
       */
      READ_ONLY(1),
      /**
       * <code>NO_HISTORY = 2;</code>
       */
      NO_HISTORY(2),
      ;

      /**
       * <code>DEFAULT_HISTORY = 0;</code>
       */
      public static final int DEFAULT_HISTORY_VALUE = 0;
      /**
       * <code>READ_ONLY = 1;</code>
       */
      public static final int READ_ONLY_VALUE = 1;
      /**
       * <code>NO_HISTORY = 2;</code>
       */
      public static final int NO_HISTORY_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static HistoryLearningLevel valueOf(int value) {
        return forNumber(value);
      }

      public static HistoryLearningLevel forNumber(int value) {
        switch (value) {
          case 0: return DEFAULT_HISTORY;
          case 1: return READ_ONLY;
          case 2: return NO_HISTORY;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<HistoryLearningLevel>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          HistoryLearningLevel> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<HistoryLearningLevel>() {
              public HistoryLearningLevel findValueByNumber(int number) {
                return HistoryLearningLevel.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(5);
      }

      private static final HistoryLearningLevel[] VALUES = values();

      public static HistoryLearningLevel valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private HistoryLearningLevel(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.HistoryLearningLevel)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.SelectionShortcut}
     */
    public enum SelectionShortcut
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NO_SHORTCUT = 0;</code>
       */
      NO_SHORTCUT(0),
      /**
       * <code>SHORTCUT_123456789 = 1;</code>
       */
      SHORTCUT_123456789(1),
      /**
       * <code>SHORTCUT_ASDFGHJKL = 2;</code>
       */
      SHORTCUT_ASDFGHJKL(2),
      ;

      /**
       * <code>NO_SHORTCUT = 0;</code>
       */
      public static final int NO_SHORTCUT_VALUE = 0;
      /**
       * <code>SHORTCUT_123456789 = 1;</code>
       */
      public static final int SHORTCUT_123456789_VALUE = 1;
      /**
       * <code>SHORTCUT_ASDFGHJKL = 2;</code>
       */
      public static final int SHORTCUT_ASDFGHJKL_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SelectionShortcut valueOf(int value) {
        return forNumber(value);
      }

      public static SelectionShortcut forNumber(int value) {
        switch (value) {
          case 0: return NO_SHORTCUT;
          case 1: return SHORTCUT_123456789;
          case 2: return SHORTCUT_ASDFGHJKL;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SelectionShortcut>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SelectionShortcut> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SelectionShortcut>() {
              public SelectionShortcut findValueByNumber(int number) {
                return SelectionShortcut.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(6);
      }

      private static final SelectionShortcut[] VALUES = values();

      public static SelectionShortcut valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private SelectionShortcut(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.SelectionShortcut)
    }

    /**
     * <pre>
     * character form (Halfwidth/Fullwidth
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.CharacterForm}
     */
    public enum CharacterForm
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>HALF_WIDTH = 0;</code>
       */
      HALF_WIDTH(0),
      /**
       * <code>FULL_WIDTH = 1;</code>
       */
      FULL_WIDTH(1),
      /**
       * <code>LAST_FORM = 2;</code>
       */
      LAST_FORM(2),
      /**
       * <code>NO_CONVERSION = 3;</code>
       */
      NO_CONVERSION(3),
      ;

      /**
       * <code>HALF_WIDTH = 0;</code>
       */
      public static final int HALF_WIDTH_VALUE = 0;
      /**
       * <code>FULL_WIDTH = 1;</code>
       */
      public static final int FULL_WIDTH_VALUE = 1;
      /**
       * <code>LAST_FORM = 2;</code>
       */
      public static final int LAST_FORM_VALUE = 2;
      /**
       * <code>NO_CONVERSION = 3;</code>
       */
      public static final int NO_CONVERSION_VALUE = 3;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static CharacterForm valueOf(int value) {
        return forNumber(value);
      }

      public static CharacterForm forNumber(int value) {
        switch (value) {
          case 0: return HALF_WIDTH;
          case 1: return FULL_WIDTH;
          case 2: return LAST_FORM;
          case 3: return NO_CONVERSION;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<CharacterForm>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          CharacterForm> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<CharacterForm>() {
              public CharacterForm findValueByNumber(int number) {
                return CharacterForm.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(7);
      }

      private static final CharacterForm[] VALUES = values();

      public static CharacterForm valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private CharacterForm(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.CharacterForm)
    }

    /**
     * <pre>
     * Shift key mode switch
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.ShiftKeyModeSwitch}
     */
    public enum ShiftKeyModeSwitch
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Case insensitive
       * </pre>
       *
       * <code>OFF = 0;</code>
       */
      OFF(0),
      /**
       * <pre>
       * MSIME, ATOK behavior
       * </pre>
       *
       * <code>ASCII_INPUT_MODE = 1;</code>
       */
      ASCII_INPUT_MODE(1),
      /**
       * <pre>
       * Kotoeri behavior
       * </pre>
       *
       * <code>KATAKANA_INPUT_MODE = 2;</code>
       */
      KATAKANA_INPUT_MODE(2),
      ;

      /**
       * <pre>
       * Case insensitive
       * </pre>
       *
       * <code>OFF = 0;</code>
       */
      public static final int OFF_VALUE = 0;
      /**
       * <pre>
       * MSIME, ATOK behavior
       * </pre>
       *
       * <code>ASCII_INPUT_MODE = 1;</code>
       */
      public static final int ASCII_INPUT_MODE_VALUE = 1;
      /**
       * <pre>
       * Kotoeri behavior
       * </pre>
       *
       * <code>KATAKANA_INPUT_MODE = 2;</code>
       */
      public static final int KATAKANA_INPUT_MODE_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ShiftKeyModeSwitch valueOf(int value) {
        return forNumber(value);
      }

      public static ShiftKeyModeSwitch forNumber(int value) {
        switch (value) {
          case 0: return OFF;
          case 1: return ASCII_INPUT_MODE;
          case 2: return KATAKANA_INPUT_MODE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ShiftKeyModeSwitch>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ShiftKeyModeSwitch> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ShiftKeyModeSwitch>() {
              public ShiftKeyModeSwitch findValueByNumber(int number) {
                return ShiftKeyModeSwitch.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(8);
      }

      private static final ShiftKeyModeSwitch[] VALUES = values();

      public static ShiftKeyModeSwitch valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private ShiftKeyModeSwitch(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.ShiftKeyModeSwitch)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.NumpadCharacterForm}
     */
    public enum NumpadCharacterForm
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NUMPAD_INPUT_MODE = 0;</code>
       */
      NUMPAD_INPUT_MODE(0),
      /**
       * <code>NUMPAD_FULL_WIDTH = 1;</code>
       */
      NUMPAD_FULL_WIDTH(1),
      /**
       * <code>NUMPAD_HALF_WIDTH = 2;</code>
       */
      NUMPAD_HALF_WIDTH(2),
      /**
       * <code>NUMPAD_DIRECT_INPUT = 3;</code>
       */
      NUMPAD_DIRECT_INPUT(3),
      ;

      /**
       * <code>NUMPAD_INPUT_MODE = 0;</code>
       */
      public static final int NUMPAD_INPUT_MODE_VALUE = 0;
      /**
       * <code>NUMPAD_FULL_WIDTH = 1;</code>
       */
      public static final int NUMPAD_FULL_WIDTH_VALUE = 1;
      /**
       * <code>NUMPAD_HALF_WIDTH = 2;</code>
       */
      public static final int NUMPAD_HALF_WIDTH_VALUE = 2;
      /**
       * <code>NUMPAD_DIRECT_INPUT = 3;</code>
       */
      public static final int NUMPAD_DIRECT_INPUT_VALUE = 3;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static NumpadCharacterForm valueOf(int value) {
        return forNumber(value);
      }

      public static NumpadCharacterForm forNumber(int value) {
        switch (value) {
          case 0: return NUMPAD_INPUT_MODE;
          case 1: return NUMPAD_FULL_WIDTH;
          case 2: return NUMPAD_HALF_WIDTH;
          case 3: return NUMPAD_DIRECT_INPUT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<NumpadCharacterForm>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          NumpadCharacterForm> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<NumpadCharacterForm>() {
              public NumpadCharacterForm findValueByNumber(int number) {
                return NumpadCharacterForm.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(9);
      }

      private static final NumpadCharacterForm[] VALUES = values();

      public static NumpadCharacterForm valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private NumpadCharacterForm(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.NumpadCharacterForm)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.AutoConversionKey}
     */
    public enum AutoConversionKey
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>AUTO_CONVERSION_OFF = 0;</code>
       */
      AUTO_CONVERSION_OFF(0),
      /**
       * <code>AUTO_CONVERSION_KUTEN = 1;</code>
       */
      AUTO_CONVERSION_KUTEN(1),
      /**
       * <code>AUTO_CONVERSION_TOUTEN = 2;</code>
       */
      AUTO_CONVERSION_TOUTEN(2),
      /**
       * <code>AUTO_CONVERSION_QUESTION_MARK = 4;</code>
       */
      AUTO_CONVERSION_QUESTION_MARK(4),
      /**
       * <code>AUTO_CONVERSION_EXCLAMATION_MARK = 8;</code>
       */
      AUTO_CONVERSION_EXCLAMATION_MARK(8),
      ;

      /**
       * <code>AUTO_CONVERSION_OFF = 0;</code>
       */
      public static final int AUTO_CONVERSION_OFF_VALUE = 0;
      /**
       * <code>AUTO_CONVERSION_KUTEN = 1;</code>
       */
      public static final int AUTO_CONVERSION_KUTEN_VALUE = 1;
      /**
       * <code>AUTO_CONVERSION_TOUTEN = 2;</code>
       */
      public static final int AUTO_CONVERSION_TOUTEN_VALUE = 2;
      /**
       * <code>AUTO_CONVERSION_QUESTION_MARK = 4;</code>
       */
      public static final int AUTO_CONVERSION_QUESTION_MARK_VALUE = 4;
      /**
       * <code>AUTO_CONVERSION_EXCLAMATION_MARK = 8;</code>
       */
      public static final int AUTO_CONVERSION_EXCLAMATION_MARK_VALUE = 8;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static AutoConversionKey valueOf(int value) {
        return forNumber(value);
      }

      public static AutoConversionKey forNumber(int value) {
        switch (value) {
          case 0: return AUTO_CONVERSION_OFF;
          case 1: return AUTO_CONVERSION_KUTEN;
          case 2: return AUTO_CONVERSION_TOUTEN;
          case 4: return AUTO_CONVERSION_QUESTION_MARK;
          case 8: return AUTO_CONVERSION_EXCLAMATION_MARK;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<AutoConversionKey>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          AutoConversionKey> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AutoConversionKey>() {
              public AutoConversionKey findValueByNumber(int number) {
                return AutoConversionKey.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(10);
      }

      private static final AutoConversionKey[] VALUES = values();

      public static AutoConversionKey valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private AutoConversionKey(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.AutoConversionKey)
    }

    /**
     * <pre>
     * Mac only config items: yen_sign_character and use_japanese_layout.
     * </pre>
     *
     * Protobuf enum {@code mozc.config.Config.YenSignCharacter}
     */
    public enum YenSignCharacter
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>YEN_SIGN = 0;</code>
       */
      YEN_SIGN(0),
      /**
       * <code>BACKSLASH = 1;</code>
       */
      BACKSLASH(1),
      ;

      /**
       * <code>YEN_SIGN = 0;</code>
       */
      public static final int YEN_SIGN_VALUE = 0;
      /**
       * <code>BACKSLASH = 1;</code>
       */
      public static final int BACKSLASH_VALUE = 1;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static YenSignCharacter valueOf(int value) {
        return forNumber(value);
      }

      public static YenSignCharacter forNumber(int value) {
        switch (value) {
          case 0: return YEN_SIGN;
          case 1: return BACKSLASH;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<YenSignCharacter>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          YenSignCharacter> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<YenSignCharacter>() {
              public YenSignCharacter findValueByNumber(int number) {
                return YenSignCharacter.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(11);
      }

      private static final YenSignCharacter[] VALUES = values();

      public static YenSignCharacter valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private YenSignCharacter(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.YenSignCharacter)
    }

    public interface CharacterFormRuleOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.config.Config.CharacterFormRule)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>optional string group = 1;</code>
       */
      boolean hasGroup();
      /**
       * <code>optional string group = 1;</code>
       */
      java.lang.String getGroup();
      /**
       * <code>optional string group = 1;</code>
       */
      com.google.protobuf.ByteString
          getGroupBytes();

      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       */
      boolean hasPreeditCharacterForm();
      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getPreeditCharacterForm();

      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       */
      boolean hasConversionCharacterForm();
      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getConversionCharacterForm();
    }
    /**
     * Protobuf type {@code mozc.config.Config.CharacterFormRule}
     */
    public  static final class CharacterFormRule extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:mozc.config.Config.CharacterFormRule)
        CharacterFormRuleOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use CharacterFormRule.newBuilder() to construct.
      private CharacterFormRule(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private CharacterFormRule() {
        group_ = "";
        preeditCharacterForm_ = 1;
        conversionCharacterForm_ = 1;
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private CharacterFormRule(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                group_ = bs;
                break;
              }
              case 16: {
                int rawValue = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.valueOf(rawValue);
                if (value == null) {
                  unknownFields.mergeVarintField(2, rawValue);
                } else {
                  bitField0_ |= 0x00000002;
                  preeditCharacterForm_ = rawValue;
                }
                break;
              }
              case 24: {
                int rawValue = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.valueOf(rawValue);
                if (value == null) {
                  unknownFields.mergeVarintField(3, rawValue);
                } else {
                  bitField0_ |= 0x00000004;
                  conversionCharacterForm_ = rawValue;
                }
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_CharacterFormRule_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_CharacterFormRule_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder.class);
      }

      private int bitField0_;
      public static final int GROUP_FIELD_NUMBER = 1;
      private volatile java.lang.Object group_;
      /**
       * <code>optional string group = 1;</code>
       */
      public boolean hasGroup() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional string group = 1;</code>
       */
      public java.lang.String getGroup() {
        java.lang.Object ref = group_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            group_ = s;
          }
          return s;
        }
      }
      /**
       * <code>optional string group = 1;</code>
       */
      public com.google.protobuf.ByteString
          getGroupBytes() {
        java.lang.Object ref = group_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          group_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int PREEDIT_CHARACTER_FORM_FIELD_NUMBER = 2;
      private int preeditCharacterForm_;
      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       */
      public boolean hasPreeditCharacterForm() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getPreeditCharacterForm() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.valueOf(preeditCharacterForm_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH : result;
      }

      public static final int CONVERSION_CHARACTER_FORM_FIELD_NUMBER = 3;
      private int conversionCharacterForm_;
      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       */
      public boolean hasConversionCharacterForm() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getConversionCharacterForm() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.valueOf(conversionCharacterForm_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH : result;
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 1, group_);
        }
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          output.writeEnum(2, preeditCharacterForm_);
        }
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          output.writeEnum(3, conversionCharacterForm_);
        }
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, group_);
        }
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(2, preeditCharacterForm_);
        }
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(3, conversionCharacterForm_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule)) {
          return super.equals(obj);
        }
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule) obj;

        boolean result = true;
        result = result && (hasGroup() == other.hasGroup());
        if (hasGroup()) {
          result = result && getGroup()
              .equals(other.getGroup());
        }
        result = result && (hasPreeditCharacterForm() == other.hasPreeditCharacterForm());
        if (hasPreeditCharacterForm()) {
          result = result && preeditCharacterForm_ == other.preeditCharacterForm_;
        }
        result = result && (hasConversionCharacterForm() == other.hasConversionCharacterForm());
        if (hasConversionCharacterForm()) {
          result = result && conversionCharacterForm_ == other.conversionCharacterForm_;
        }
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasGroup()) {
          hash = (37 * hash) + GROUP_FIELD_NUMBER;
          hash = (53 * hash) + getGroup().hashCode();
        }
        if (hasPreeditCharacterForm()) {
          hash = (37 * hash) + PREEDIT_CHARACTER_FORM_FIELD_NUMBER;
          hash = (53 * hash) + preeditCharacterForm_;
        }
        if (hasConversionCharacterForm()) {
          hash = (37 * hash) + CONVERSION_CHARACTER_FORM_FIELD_NUMBER;
          hash = (53 * hash) + conversionCharacterForm_;
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code mozc.config.Config.CharacterFormRule}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.config.Config.CharacterFormRule)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_CharacterFormRule_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_CharacterFormRule_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder.class);
        }

        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          group_ = "";
          bitField0_ = (bitField0_ & ~0x00000001);
          preeditCharacterForm_ = 1;
          bitField0_ = (bitField0_ & ~0x00000002);
          conversionCharacterForm_ = 1;
          bitField0_ = (bitField0_ & ~0x00000004);
          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_CharacterFormRule_descriptor;
        }

        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getDefaultInstanceForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.getDefaultInstance();
        }

        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule build() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule buildPartial() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
            to_bitField0_ |= 0x00000001;
          }
          result.group_ = group_;
          if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
            to_bitField0_ |= 0x00000002;
          }
          result.preeditCharacterForm_ = preeditCharacterForm_;
          if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
            to_bitField0_ |= 0x00000004;
          }
          result.conversionCharacterForm_ = conversionCharacterForm_;
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule) {
            return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule other) {
          if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.getDefaultInstance()) return this;
          if (other.hasGroup()) {
            bitField0_ |= 0x00000001;
            group_ = other.group_;
            onChanged();
          }
          if (other.hasPreeditCharacterForm()) {
            setPreeditCharacterForm(other.getPreeditCharacterForm());
          }
          if (other.hasConversionCharacterForm()) {
            setConversionCharacterForm(other.getConversionCharacterForm());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private java.lang.Object group_ = "";
        /**
         * <code>optional string group = 1;</code>
         */
        public boolean hasGroup() {
          return ((bitField0_ & 0x00000001) == 0x00000001);
        }
        /**
         * <code>optional string group = 1;</code>
         */
        public java.lang.String getGroup() {
          java.lang.Object ref = group_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              group_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <code>optional string group = 1;</code>
         */
        public com.google.protobuf.ByteString
            getGroupBytes() {
          java.lang.Object ref = group_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            group_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <code>optional string group = 1;</code>
         */
        public Builder setGroup(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
          group_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional string group = 1;</code>
         */
        public Builder clearGroup() {
          bitField0_ = (bitField0_ & ~0x00000001);
          group_ = getDefaultInstance().getGroup();
          onChanged();
          return this;
        }
        /**
         * <code>optional string group = 1;</code>
         */
        public Builder setGroupBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
          group_ = value;
          onChanged();
          return this;
        }

        private int preeditCharacterForm_ = 1;
        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         */
        public boolean hasPreeditCharacterForm() {
          return ((bitField0_ & 0x00000002) == 0x00000002);
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         */
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getPreeditCharacterForm() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.valueOf(preeditCharacterForm_);
          return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH : result;
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         */
        public Builder setPreeditCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000002;
          preeditCharacterForm_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         */
        public Builder clearPreeditCharacterForm() {
          bitField0_ = (bitField0_ & ~0x00000002);
          preeditCharacterForm_ = 1;
          onChanged();
          return this;
        }

        private int conversionCharacterForm_ = 1;
        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         */
        public boolean hasConversionCharacterForm() {
          return ((bitField0_ & 0x00000004) == 0x00000004);
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         */
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getConversionCharacterForm() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.valueOf(conversionCharacterForm_);
          return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH : result;
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         */
        public Builder setConversionCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000004;
          conversionCharacterForm_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         */
        public Builder clearConversionCharacterForm() {
          bitField0_ = (bitField0_ & ~0x00000004);
          conversionCharacterForm_ = 1;
          onChanged();
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:mozc.config.Config.CharacterFormRule)
      }

      // @@protoc_insertion_point(class_scope:mozc.config.Config.CharacterFormRule)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule();
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<CharacterFormRule>
          PARSER = new com.google.protobuf.AbstractParser<CharacterFormRule>() {
        public CharacterFormRule parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new CharacterFormRule(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<CharacterFormRule> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<CharacterFormRule> getParserForType() {
        return PARSER;
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface InformationListConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:mozc.config.Config.InformationListConfig)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       */
      boolean hasUseLocalUsageDictionary();
      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       */
      boolean getUseLocalUsageDictionary();
    }
    /**
     * Protobuf type {@code mozc.config.Config.InformationListConfig}
     */
    public  static final class InformationListConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:mozc.config.Config.InformationListConfig)
        InformationListConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use InformationListConfig.newBuilder() to construct.
      private InformationListConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private InformationListConfig() {
        useLocalUsageDictionary_ = true;
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private InformationListConfig(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                bitField0_ |= 0x00000001;
                useLocalUsageDictionary_ = input.readBool();
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_InformationListConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_InformationListConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder.class);
      }

      private int bitField0_;
      public static final int USE_LOCAL_USAGE_DICTIONARY_FIELD_NUMBER = 1;
      private boolean useLocalUsageDictionary_;
      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       */
      public boolean hasUseLocalUsageDictionary() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       */
      public boolean getUseLocalUsageDictionary() {
        return useLocalUsageDictionary_;
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          output.writeBool(1, useLocalUsageDictionary_);
        }
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(1, useLocalUsageDictionary_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig)) {
          return super.equals(obj);
        }
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig) obj;

        boolean result = true;
        result = result && (hasUseLocalUsageDictionary() == other.hasUseLocalUsageDictionary());
        if (hasUseLocalUsageDictionary()) {
          result = result && (getUseLocalUsageDictionary()
              == other.getUseLocalUsageDictionary());
        }
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasUseLocalUsageDictionary()) {
          hash = (37 * hash) + USE_LOCAL_USAGE_DICTIONARY_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
              getUseLocalUsageDictionary());
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code mozc.config.Config.InformationListConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:mozc.config.Config.InformationListConfig)
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_InformationListConfig_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_InformationListConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder.class);
        }

        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          useLocalUsageDictionary_ = true;
          bitField0_ = (bitField0_ & ~0x00000001);
          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_InformationListConfig_descriptor;
        }

        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getDefaultInstanceForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance();
        }

        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig build() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig buildPartial() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
            to_bitField0_ |= 0x00000001;
          }
          result.useLocalUsageDictionary_ = useLocalUsageDictionary_;
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig) {
            return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig other) {
          if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance()) return this;
          if (other.hasUseLocalUsageDictionary()) {
            setUseLocalUsageDictionary(other.getUseLocalUsageDictionary());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private boolean useLocalUsageDictionary_ = true;
        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         */
        public boolean hasUseLocalUsageDictionary() {
          return ((bitField0_ & 0x00000001) == 0x00000001);
        }
        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         */
        public boolean getUseLocalUsageDictionary() {
          return useLocalUsageDictionary_;
        }
        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         */
        public Builder setUseLocalUsageDictionary(boolean value) {
          bitField0_ |= 0x00000001;
          useLocalUsageDictionary_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         */
        public Builder clearUseLocalUsageDictionary() {
          bitField0_ = (bitField0_ & ~0x00000001);
          useLocalUsageDictionary_ = true;
          onChanged();
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:mozc.config.Config.InformationListConfig)
      }

      // @@protoc_insertion_point(class_scope:mozc.config.Config.InformationListConfig)
      private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig();
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<InformationListConfig>
          PARSER = new com.google.protobuf.AbstractParser<InformationListConfig>() {
        public InformationListConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new InformationListConfig(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<InformationListConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<InformationListConfig> getParserForType() {
        return PARSER;
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    private int bitField1_;
    public static final int GENERAL_CONFIG_FIELD_NUMBER = 1;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig generalConfig_;
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     */
    public boolean hasGeneralConfig() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getGeneralConfig() {
      return generalConfig_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance() : generalConfig_;
    }
    /**
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     *
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder getGeneralConfigOrBuilder() {
      return generalConfig_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance() : generalConfig_;
    }

    public static final int VERBOSE_LEVEL_FIELD_NUMBER = 10;
    private int verboseLevel_;
    /**
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     *
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     */
    public boolean hasVerboseLevel() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     *
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     */
    public int getVerboseLevel() {
      return verboseLevel_;
    }

    public static final int INCOGNITO_MODE_FIELD_NUMBER = 20;
    private boolean incognitoMode_;
    /**
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * </pre>
     *
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     */
    public boolean hasIncognitoMode() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * </pre>
     *
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     */
    public boolean getIncognitoMode() {
      return incognitoMode_;
    }

    public static final int CHECK_DEFAULT_FIELD_NUMBER = 22;
    private boolean checkDefault_;
    /**
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     *
     * <code>optional bool check_default = 22 [default = true];</code>
     */
    public boolean hasCheckDefault() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     *
     * <code>optional bool check_default = 22 [default = true];</code>
     */
    public boolean getCheckDefault() {
      return checkDefault_;
    }

    public static final int PRESENTATION_MODE_FIELD_NUMBER = 23;
    private boolean presentationMode_;
    /**
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     *
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     */
    public boolean hasPresentationMode() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     *
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     */
    public boolean getPresentationMode() {
      return presentationMode_;
    }

    public static final int PREEDIT_METHOD_FIELD_NUMBER = 40;
    private int preeditMethod_;
    /**
     * <pre>
     * Roman/Kana
     * </pre>
     *
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     */
    public boolean hasPreeditMethod() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * Roman/Kana
     * </pre>
     *
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod getPreeditMethod() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.valueOf(preeditMethod_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.ROMAN : result;
    }

    public static final int SESSION_KEYMAP_FIELD_NUMBER = 41;
    private int sessionKeymap_;
    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     */
    public boolean hasSessionKeymap() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getSessionKeymap() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.valueOf(sessionKeymap_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.NONE : result;
    }

    public static final int CUSTOM_KEYMAP_TABLE_FIELD_NUMBER = 42;
    private com.google.protobuf.ByteString customKeymapTable_;
    /**
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     *
     * <code>optional bytes custom_keymap_table = 42;</code>
     */
    public boolean hasCustomKeymapTable() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     *
     * <code>optional bytes custom_keymap_table = 42;</code>
     */
    public com.google.protobuf.ByteString getCustomKeymapTable() {
      return customKeymapTable_;
    }

    public static final int CUSTOM_ROMAN_TABLE_FIELD_NUMBER = 43;
    private com.google.protobuf.ByteString customRomanTable_;
    /**
     * <pre>
     * custom roman table
     * </pre>
     *
     * <code>optional bytes custom_roman_table = 43;</code>
     */
    public boolean hasCustomRomanTable() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <pre>
     * custom roman table
     * </pre>
     *
     * <code>optional bytes custom_roman_table = 43;</code>
     */
    public com.google.protobuf.ByteString getCustomRomanTable() {
      return customRomanTable_;
    }

    public static final int PUNCTUATION_METHOD_FIELD_NUMBER = 45;
    private int punctuationMethod_;
    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
     */
    public boolean hasPunctuationMethod() {
      return ((bitField0_ & 0x00000200) == 0x00000200);
    }
    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod getPunctuationMethod() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.valueOf(punctuationMethod_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.KUTEN_TOUTEN : result;
    }

    public static final int SYMBOL_METHOD_FIELD_NUMBER = 46;
    private int symbolMethod_;
    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     */
    public boolean hasSymbolMethod() {
      return ((bitField0_ & 0x00000400) == 0x00000400);
    }
    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod getSymbolMethod() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.valueOf(symbolMethod_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.CORNER_BRACKET_MIDDLE_DOT : result;
    }

    public static final int SPACE_CHARACTER_FORM_FIELD_NUMBER = 47;
    private int spaceCharacterForm_;
    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     */
    public boolean hasSpaceCharacterForm() {
      return ((bitField0_ & 0x00000800) == 0x00000800);
    }
    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm getSpaceCharacterForm() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.valueOf(spaceCharacterForm_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.FUNDAMENTAL_INPUT_MODE : result;
    }

    public static final int USE_KEYBOARD_TO_CHANGE_PREEDIT_METHOD_FIELD_NUMBER = 48;
    private boolean useKeyboardToChangePreeditMethod_;
    /**
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     *
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     */
    public boolean hasUseKeyboardToChangePreeditMethod() {
      return ((bitField0_ & 0x00001000) == 0x00001000);
    }
    /**
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     *
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     */
    public boolean getUseKeyboardToChangePreeditMethod() {
      return useKeyboardToChangePreeditMethod_;
    }

    public static final int HISTORY_LEARNING_LEVEL_FIELD_NUMBER = 50;
    private int historyLearningLevel_;
    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     */
    public boolean hasHistoryLearningLevel() {
      return ((bitField0_ & 0x00002000) == 0x00002000);
    }
    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel getHistoryLearningLevel() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.valueOf(historyLearningLevel_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.DEFAULT_HISTORY : result;
    }

    public static final int SELECTION_SHORTCUT_FIELD_NUMBER = 52;
    private int selectionShortcut_;
    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     */
    public boolean hasSelectionShortcut() {
      return ((bitField0_ & 0x00004000) == 0x00004000);
    }
    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut getSelectionShortcut() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.valueOf(selectionShortcut_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.SHORTCUT_123456789 : result;
    }

    public static final int CHARACTER_FORM_RULES_FIELD_NUMBER = 54;
    private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> characterFormRules_;
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> getCharacterFormRulesList() {
      return characterFormRules_;
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> 
        getCharacterFormRulesOrBuilderList() {
      return characterFormRules_;
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    public int getCharacterFormRulesCount() {
      return characterFormRules_.size();
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getCharacterFormRules(int index) {
      return characterFormRules_.get(index);
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder getCharacterFormRulesOrBuilder(
        int index) {
      return characterFormRules_.get(index);
    }

    public static final int USE_AUTO_IME_TURN_OFF_FIELD_NUMBER = 56;
    private boolean useAutoImeTurnOff_;
    /**
     * <pre>
     * auto IME turn off feature
     * </pre>
     *
     * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
     */
    public boolean hasUseAutoImeTurnOff() {
      return ((bitField0_ & 0x00008000) == 0x00008000);
    }
    /**
     * <pre>
     * auto IME turn off feature
     * </pre>
     *
     * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
     */
    public boolean getUseAutoImeTurnOff() {
      return useAutoImeTurnOff_;
    }

    public static final int USE_CASCADING_WINDOW_FIELD_NUMBER = 58;
    private boolean useCascadingWindow_;
    /**
     * <pre>
     * Toggle to use cascanding window for debuging.
     * </pre>
     *
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     */
    public boolean hasUseCascadingWindow() {
      return ((bitField0_ & 0x00010000) == 0x00010000);
    }
    /**
     * <pre>
     * Toggle to use cascanding window for debuging.
     * </pre>
     *
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     */
    public boolean getUseCascadingWindow() {
      return useCascadingWindow_;
    }

    public static final int SHIFT_KEY_MODE_SWITCH_FIELD_NUMBER = 59;
    private int shiftKeyModeSwitch_;
    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     */
    public boolean hasShiftKeyModeSwitch() {
      return ((bitField0_ & 0x00020000) == 0x00020000);
    }
    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch getShiftKeyModeSwitch() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.valueOf(shiftKeyModeSwitch_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.ASCII_INPUT_MODE : result;
    }

    public static final int NUMPAD_CHARACTER_FORM_FIELD_NUMBER = 60;
    private int numpadCharacterForm_;
    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     */
    public boolean hasNumpadCharacterForm() {
      return ((bitField0_ & 0x00040000) == 0x00040000);
    }
    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm getNumpadCharacterForm() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.valueOf(numpadCharacterForm_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.NUMPAD_HALF_WIDTH : result;
    }

    public static final int USE_AUTO_CONVERSION_FIELD_NUMBER = 61;
    private boolean useAutoConversion_;
    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     */
    public boolean hasUseAutoConversion() {
      return ((bitField0_ & 0x00080000) == 0x00080000);
    }
    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     */
    public boolean getUseAutoConversion() {
      return useAutoConversion_;
    }

    public static final int AUTO_CONVERSION_KEY_FIELD_NUMBER = 62;
    private int autoConversionKey_;
    /**
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     *
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     */
    public boolean hasAutoConversionKey() {
      return ((bitField0_ & 0x00100000) == 0x00100000);
    }
    /**
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     *
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     */
    public int getAutoConversionKey() {
      return autoConversionKey_;
    }

    public static final int YEN_SIGN_CHARACTER_FIELD_NUMBER = 63;
    private int yenSignCharacter_;
    /**
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     *
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     */
    public boolean hasYenSignCharacter() {
      return ((bitField0_ & 0x00200000) == 0x00200000);
    }
    /**
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     *
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter getYenSignCharacter() {
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.valueOf(yenSignCharacter_);
      return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.YEN_SIGN : result;
    }

    public static final int USE_JAPANESE_LAYOUT_FIELD_NUMBER = 64;
    private boolean useJapaneseLayout_;
    /**
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     *
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     */
    public boolean hasUseJapaneseLayout() {
      return ((bitField0_ & 0x00400000) == 0x00400000);
    }
    /**
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     *
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     */
    public boolean getUseJapaneseLayout() {
      return useJapaneseLayout_;
    }

    public static final int USE_KANA_MODIFIER_INSENSITIVE_CONVERSION_FIELD_NUMBER = 65;
    private boolean useKanaModifierInsensitiveConversion_;
    /**
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     *
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     */
    public boolean hasUseKanaModifierInsensitiveConversion() {
      return ((bitField0_ & 0x00800000) == 0x00800000);
    }
    /**
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     *
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     */
    public boolean getUseKanaModifierInsensitiveConversion() {
      return useKanaModifierInsensitiveConversion_;
    }

    public static final int USE_TYPING_CORRECTION_FIELD_NUMBER = 66;
    private boolean useTypingCorrection_;
    /**
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     *
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     */
    public boolean hasUseTypingCorrection() {
      return ((bitField0_ & 0x01000000) == 0x01000000);
    }
    /**
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     *
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     */
    public boolean getUseTypingCorrection() {
      return useTypingCorrection_;
    }

    public static final int USE_DATE_CONVERSION_FIELD_NUMBER = 80;
    private boolean useDateConversion_;
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Dictionary (80-99)
     * </pre>
     *
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     */
    public boolean hasUseDateConversion() {
      return ((bitField0_ & 0x02000000) == 0x02000000);
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Dictionary (80-99)
     * </pre>
     *
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     */
    public boolean getUseDateConversion() {
      return useDateConversion_;
    }

    public static final int USE_SINGLE_KANJI_CONVERSION_FIELD_NUMBER = 81;
    private boolean useSingleKanjiConversion_;
    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     */
    public boolean hasUseSingleKanjiConversion() {
      return ((bitField0_ & 0x04000000) == 0x04000000);
    }
    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     */
    public boolean getUseSingleKanjiConversion() {
      return useSingleKanjiConversion_;
    }

    public static final int USE_SYMBOL_CONVERSION_FIELD_NUMBER = 82;
    private boolean useSymbolConversion_;
    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     */
    public boolean hasUseSymbolConversion() {
      return ((bitField0_ & 0x08000000) == 0x08000000);
    }
    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     */
    public boolean getUseSymbolConversion() {
      return useSymbolConversion_;
    }

    public static final int USE_NUMBER_CONVERSION_FIELD_NUMBER = 83;
    private boolean useNumberConversion_;
    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     */
    public boolean hasUseNumberConversion() {
      return ((bitField0_ & 0x10000000) == 0x10000000);
    }
    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     */
    public boolean getUseNumberConversion() {
      return useNumberConversion_;
    }

    public static final int USE_EMOTICON_CONVERSION_FIELD_NUMBER = 84;
    private boolean useEmoticonConversion_;
    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     */
    public boolean hasUseEmoticonConversion() {
      return ((bitField0_ & 0x20000000) == 0x20000000);
    }
    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     */
    public boolean getUseEmoticonConversion() {
      return useEmoticonConversion_;
    }

    public static final int USE_CALCULATOR_FIELD_NUMBER = 85;
    private boolean useCalculator_;
    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     */
    public boolean hasUseCalculator() {
      return ((bitField0_ & 0x40000000) == 0x40000000);
    }
    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     */
    public boolean getUseCalculator() {
      return useCalculator_;
    }

    public static final int USE_T13N_CONVERSION_FIELD_NUMBER = 86;
    private boolean useT13NConversion_;
    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     */
    public boolean hasUseT13NConversion() {
      return ((bitField0_ & 0x80000000) == 0x80000000);
    }
    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     */
    public boolean getUseT13NConversion() {
      return useT13NConversion_;
    }

    public static final int USE_ZIP_CODE_CONVERSION_FIELD_NUMBER = 87;
    private boolean useZipCodeConversion_;
    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     */
    public boolean hasUseZipCodeConversion() {
      return ((bitField1_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     */
    public boolean getUseZipCodeConversion() {
      return useZipCodeConversion_;
    }

    public static final int USE_SPELLING_CORRECTION_FIELD_NUMBER = 88;
    private boolean useSpellingCorrection_;
    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     */
    public boolean hasUseSpellingCorrection() {
      return ((bitField1_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     */
    public boolean getUseSpellingCorrection() {
      return useSpellingCorrection_;
    }

    public static final int USE_EMOJI_CONVERSION_FIELD_NUMBER = 89;
    private boolean useEmojiConversion_;
    /**
     * <pre>
     * If use_emoji_conversion is true, the user can input emoji characters
     * by converting from a query string (e.g. "  " [U+1F436]).
     * Even if it is false, users might be able to input emoji characters
     * with other ways.
     * Note: Some characters can be either of text and emoji.  It would be ideal
     * to use the variation sequence to specify emoji presentation [U+FE0E],
     * although it is not implemented yet.
     * See: http://unicode.org/reports/tr51/#Presentation_Style
     * </pre>
     *
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     */
    public boolean hasUseEmojiConversion() {
      return ((bitField1_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * If use_emoji_conversion is true, the user can input emoji characters
     * by converting from a query string (e.g. "  " [U+1F436]).
     * Even if it is false, users might be able to input emoji characters
     * with other ways.
     * Note: Some characters can be either of text and emoji.  It would be ideal
     * to use the variation sequence to specify emoji presentation [U+FE0E],
     * although it is not implemented yet.
     * See: http://unicode.org/reports/tr51/#Presentation_Style
     * </pre>
     *
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     */
    public boolean getUseEmojiConversion() {
      return useEmojiConversion_;
    }

    public static final int INFORMATION_LIST_CONFIG_FIELD_NUMBER = 90;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig informationListConfig_;
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    public boolean hasInformationListConfig() {
      return ((bitField1_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getInformationListConfig() {
      return informationListConfig_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance() : informationListConfig_;
    }
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder getInformationListConfigOrBuilder() {
      return informationListConfig_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance() : informationListConfig_;
    }

    public static final int USE_HISTORY_SUGGEST_FIELD_NUMBER = 100;
    private boolean useHistorySuggest_;
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Suggest (100-119)
     * Use history-based suggest feature.
     * </pre>
     *
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     */
    public boolean hasUseHistorySuggest() {
      return ((bitField1_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Suggest (100-119)
     * Use history-based suggest feature.
     * </pre>
     *
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     */
    public boolean getUseHistorySuggest() {
      return useHistorySuggest_;
    }

    public static final int USE_DICTIONARY_SUGGEST_FIELD_NUMBER = 101;
    private boolean useDictionarySuggest_;
    /**
     * <pre>
     * Use dictionary-based suggest feature.
     * </pre>
     *
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     */
    public boolean hasUseDictionarySuggest() {
      return ((bitField1_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * Use dictionary-based suggest feature.
     * </pre>
     *
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     */
    public boolean getUseDictionarySuggest() {
      return useDictionarySuggest_;
    }

    public static final int USE_REALTIME_CONVERSION_FIELD_NUMBER = 102;
    private boolean useRealtimeConversion_;
    /**
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     *
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     */
    public boolean hasUseRealtimeConversion() {
      return ((bitField1_ & 0x00000040) == 0x00000040);
    }
    /**
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     *
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     */
    public boolean getUseRealtimeConversion() {
      return useRealtimeConversion_;
    }

    public static final int SUGGESTIONS_SIZE_FIELD_NUMBER = 110;
    private int suggestionsSize_;
    /**
     * <pre>
     * Size of suggestions.
     * </pre>
     *
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     */
    public boolean hasSuggestionsSize() {
      return ((bitField1_ & 0x00000080) == 0x00000080);
    }
    /**
     * <pre>
     * Size of suggestions.
     * </pre>
     *
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     */
    public int getSuggestionsSize() {
      return suggestionsSize_;
    }

    public static final int USE_MODE_INDICATOR_FIELD_NUMBER = 120;
    private boolean useModeIndicator_;
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Renderer (120-139)
     * Use mode indicator feature.
     * </pre>
     *
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     */
    public boolean hasUseModeIndicator() {
      return ((bitField1_ & 0x00000100) == 0x00000100);
    }
    /**
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     * Renderer (120-139)
     * Use mode indicator feature.
     * </pre>
     *
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     */
    public boolean getUseModeIndicator() {
      return useModeIndicator_;
    }

    public static final int ALLOW_CLOUD_HANDWRITING_FIELD_NUMBER = 301;
    private boolean allowCloudHandwriting_;
    /**
     * <pre>
     * Allow the cloud handwriting.  The handwriting UI has to notice
     * user before activating the feature, and set this field to true
     * when the user permit.
     * NOTE: OSS version does not handle this field.
     * </pre>
     *
     * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
     */
    public boolean hasAllowCloudHandwriting() {
      return ((bitField1_ & 0x00000200) == 0x00000200);
    }
    /**
     * <pre>
     * Allow the cloud handwriting.  The handwriting UI has to notice
     * user before activating the feature, and set this field to true
     * when the user permit.
     * NOTE: OSS version does not handle this field.
     * </pre>
     *
     * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
     */
    public boolean getAllowCloudHandwriting() {
      return allowCloudHandwriting_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getGeneralConfig());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(10, verboseLevel_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBool(20, incognitoMode_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeBool(22, checkDefault_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeBool(23, presentationMode_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeEnum(40, preeditMethod_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeEnum(41, sessionKeymap_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeBytes(42, customKeymapTable_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeBytes(43, customRomanTable_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeEnum(45, punctuationMethod_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeEnum(46, symbolMethod_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        output.writeEnum(47, spaceCharacterForm_);
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        output.writeBool(48, useKeyboardToChangePreeditMethod_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        output.writeEnum(50, historyLearningLevel_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        output.writeEnum(52, selectionShortcut_);
      }
      for (int i = 0; i < characterFormRules_.size(); i++) {
        output.writeMessage(54, characterFormRules_.get(i));
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        output.writeBool(56, useAutoImeTurnOff_);
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        output.writeBool(58, useCascadingWindow_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        output.writeEnum(59, shiftKeyModeSwitch_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        output.writeEnum(60, numpadCharacterForm_);
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        output.writeBool(61, useAutoConversion_);
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        output.writeUInt32(62, autoConversionKey_);
      }
      if (((bitField0_ & 0x00200000) == 0x00200000)) {
        output.writeEnum(63, yenSignCharacter_);
      }
      if (((bitField0_ & 0x00400000) == 0x00400000)) {
        output.writeBool(64, useJapaneseLayout_);
      }
      if (((bitField0_ & 0x00800000) == 0x00800000)) {
        output.writeBool(65, useKanaModifierInsensitiveConversion_);
      }
      if (((bitField0_ & 0x01000000) == 0x01000000)) {
        output.writeBool(66, useTypingCorrection_);
      }
      if (((bitField0_ & 0x02000000) == 0x02000000)) {
        output.writeBool(80, useDateConversion_);
      }
      if (((bitField0_ & 0x04000000) == 0x04000000)) {
        output.writeBool(81, useSingleKanjiConversion_);
      }
      if (((bitField0_ & 0x08000000) == 0x08000000)) {
        output.writeBool(82, useSymbolConversion_);
      }
      if (((bitField0_ & 0x10000000) == 0x10000000)) {
        output.writeBool(83, useNumberConversion_);
      }
      if (((bitField0_ & 0x20000000) == 0x20000000)) {
        output.writeBool(84, useEmoticonConversion_);
      }
      if (((bitField0_ & 0x40000000) == 0x40000000)) {
        output.writeBool(85, useCalculator_);
      }
      if (((bitField0_ & 0x80000000) == 0x80000000)) {
        output.writeBool(86, useT13NConversion_);
      }
      if (((bitField1_ & 0x00000001) == 0x00000001)) {
        output.writeBool(87, useZipCodeConversion_);
      }
      if (((bitField1_ & 0x00000002) == 0x00000002)) {
        output.writeBool(88, useSpellingCorrection_);
      }
      if (((bitField1_ & 0x00000004) == 0x00000004)) {
        output.writeBool(89, useEmojiConversion_);
      }
      if (((bitField1_ & 0x00000008) == 0x00000008)) {
        output.writeMessage(90, getInformationListConfig());
      }
      if (((bitField1_ & 0x00000010) == 0x00000010)) {
        output.writeBool(100, useHistorySuggest_);
      }
      if (((bitField1_ & 0x00000020) == 0x00000020)) {
        output.writeBool(101, useDictionarySuggest_);
      }
      if (((bitField1_ & 0x00000040) == 0x00000040)) {
        output.writeBool(102, useRealtimeConversion_);
      }
      if (((bitField1_ & 0x00000080) == 0x00000080)) {
        output.writeUInt32(110, suggestionsSize_);
      }
      if (((bitField1_ & 0x00000100) == 0x00000100)) {
        output.writeBool(120, useModeIndicator_);
      }
      if (((bitField1_ & 0x00000200) == 0x00000200)) {
        output.writeBool(301, allowCloudHandwriting_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getGeneralConfig());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(10, verboseLevel_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(20, incognitoMode_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(22, checkDefault_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(23, presentationMode_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(40, preeditMethod_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(41, sessionKeymap_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(42, customKeymapTable_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(43, customRomanTable_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(45, punctuationMethod_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(46, symbolMethod_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(47, spaceCharacterForm_);
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(48, useKeyboardToChangePreeditMethod_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(50, historyLearningLevel_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(52, selectionShortcut_);
      }
      for (int i = 0; i < characterFormRules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(54, characterFormRules_.get(i));
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(56, useAutoImeTurnOff_);
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(58, useCascadingWindow_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(59, shiftKeyModeSwitch_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(60, numpadCharacterForm_);
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(61, useAutoConversion_);
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(62, autoConversionKey_);
      }
      if (((bitField0_ & 0x00200000) == 0x00200000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(63, yenSignCharacter_);
      }
      if (((bitField0_ & 0x00400000) == 0x00400000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(64, useJapaneseLayout_);
      }
      if (((bitField0_ & 0x00800000) == 0x00800000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(65, useKanaModifierInsensitiveConversion_);
      }
      if (((bitField0_ & 0x01000000) == 0x01000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(66, useTypingCorrection_);
      }
      if (((bitField0_ & 0x02000000) == 0x02000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(80, useDateConversion_);
      }
      if (((bitField0_ & 0x04000000) == 0x04000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(81, useSingleKanjiConversion_);
      }
      if (((bitField0_ & 0x08000000) == 0x08000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(82, useSymbolConversion_);
      }
      if (((bitField0_ & 0x10000000) == 0x10000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(83, useNumberConversion_);
      }
      if (((bitField0_ & 0x20000000) == 0x20000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(84, useEmoticonConversion_);
      }
      if (((bitField0_ & 0x40000000) == 0x40000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(85, useCalculator_);
      }
      if (((bitField0_ & 0x80000000) == 0x80000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(86, useT13NConversion_);
      }
      if (((bitField1_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(87, useZipCodeConversion_);
      }
      if (((bitField1_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(88, useSpellingCorrection_);
      }
      if (((bitField1_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(89, useEmojiConversion_);
      }
      if (((bitField1_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(90, getInformationListConfig());
      }
      if (((bitField1_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(100, useHistorySuggest_);
      }
      if (((bitField1_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(101, useDictionarySuggest_);
      }
      if (((bitField1_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(102, useRealtimeConversion_);
      }
      if (((bitField1_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(110, suggestionsSize_);
      }
      if (((bitField1_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(120, useModeIndicator_);
      }
      if (((bitField1_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(301, allowCloudHandwriting_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config)) {
        return super.equals(obj);
      }
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config other = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config) obj;

      boolean result = true;
      result = result && (hasGeneralConfig() == other.hasGeneralConfig());
      if (hasGeneralConfig()) {
        result = result && getGeneralConfig()
            .equals(other.getGeneralConfig());
      }
      result = result && (hasVerboseLevel() == other.hasVerboseLevel());
      if (hasVerboseLevel()) {
        result = result && (getVerboseLevel()
            == other.getVerboseLevel());
      }
      result = result && (hasIncognitoMode() == other.hasIncognitoMode());
      if (hasIncognitoMode()) {
        result = result && (getIncognitoMode()
            == other.getIncognitoMode());
      }
      result = result && (hasCheckDefault() == other.hasCheckDefault());
      if (hasCheckDefault()) {
        result = result && (getCheckDefault()
            == other.getCheckDefault());
      }
      result = result && (hasPresentationMode() == other.hasPresentationMode());
      if (hasPresentationMode()) {
        result = result && (getPresentationMode()
            == other.getPresentationMode());
      }
      result = result && (hasPreeditMethod() == other.hasPreeditMethod());
      if (hasPreeditMethod()) {
        result = result && preeditMethod_ == other.preeditMethod_;
      }
      result = result && (hasSessionKeymap() == other.hasSessionKeymap());
      if (hasSessionKeymap()) {
        result = result && sessionKeymap_ == other.sessionKeymap_;
      }
      result = result && (hasCustomKeymapTable() == other.hasCustomKeymapTable());
      if (hasCustomKeymapTable()) {
        result = result && getCustomKeymapTable()
            .equals(other.getCustomKeymapTable());
      }
      result = result && (hasCustomRomanTable() == other.hasCustomRomanTable());
      if (hasCustomRomanTable()) {
        result = result && getCustomRomanTable()
            .equals(other.getCustomRomanTable());
      }
      result = result && (hasPunctuationMethod() == other.hasPunctuationMethod());
      if (hasPunctuationMethod()) {
        result = result && punctuationMethod_ == other.punctuationMethod_;
      }
      result = result && (hasSymbolMethod() == other.hasSymbolMethod());
      if (hasSymbolMethod()) {
        result = result && symbolMethod_ == other.symbolMethod_;
      }
      result = result && (hasSpaceCharacterForm() == other.hasSpaceCharacterForm());
      if (hasSpaceCharacterForm()) {
        result = result && spaceCharacterForm_ == other.spaceCharacterForm_;
      }
      result = result && (hasUseKeyboardToChangePreeditMethod() == other.hasUseKeyboardToChangePreeditMethod());
      if (hasUseKeyboardToChangePreeditMethod()) {
        result = result && (getUseKeyboardToChangePreeditMethod()
            == other.getUseKeyboardToChangePreeditMethod());
      }
      result = result && (hasHistoryLearningLevel() == other.hasHistoryLearningLevel());
      if (hasHistoryLearningLevel()) {
        result = result && historyLearningLevel_ == other.historyLearningLevel_;
      }
      result = result && (hasSelectionShortcut() == other.hasSelectionShortcut());
      if (hasSelectionShortcut()) {
        result = result && selectionShortcut_ == other.selectionShortcut_;
      }
      result = result && getCharacterFormRulesList()
          .equals(other.getCharacterFormRulesList());
      result = result && (hasUseAutoImeTurnOff() == other.hasUseAutoImeTurnOff());
      if (hasUseAutoImeTurnOff()) {
        result = result && (getUseAutoImeTurnOff()
            == other.getUseAutoImeTurnOff());
      }
      result = result && (hasUseCascadingWindow() == other.hasUseCascadingWindow());
      if (hasUseCascadingWindow()) {
        result = result && (getUseCascadingWindow()
            == other.getUseCascadingWindow());
      }
      result = result && (hasShiftKeyModeSwitch() == other.hasShiftKeyModeSwitch());
      if (hasShiftKeyModeSwitch()) {
        result = result && shiftKeyModeSwitch_ == other.shiftKeyModeSwitch_;
      }
      result = result && (hasNumpadCharacterForm() == other.hasNumpadCharacterForm());
      if (hasNumpadCharacterForm()) {
        result = result && numpadCharacterForm_ == other.numpadCharacterForm_;
      }
      result = result && (hasUseAutoConversion() == other.hasUseAutoConversion());
      if (hasUseAutoConversion()) {
        result = result && (getUseAutoConversion()
            == other.getUseAutoConversion());
      }
      result = result && (hasAutoConversionKey() == other.hasAutoConversionKey());
      if (hasAutoConversionKey()) {
        result = result && (getAutoConversionKey()
            == other.getAutoConversionKey());
      }
      result = result && (hasYenSignCharacter() == other.hasYenSignCharacter());
      if (hasYenSignCharacter()) {
        result = result && yenSignCharacter_ == other.yenSignCharacter_;
      }
      result = result && (hasUseJapaneseLayout() == other.hasUseJapaneseLayout());
      if (hasUseJapaneseLayout()) {
        result = result && (getUseJapaneseLayout()
            == other.getUseJapaneseLayout());
      }
      result = result && (hasUseKanaModifierInsensitiveConversion() == other.hasUseKanaModifierInsensitiveConversion());
      if (hasUseKanaModifierInsensitiveConversion()) {
        result = result && (getUseKanaModifierInsensitiveConversion()
            == other.getUseKanaModifierInsensitiveConversion());
      }
      result = result && (hasUseTypingCorrection() == other.hasUseTypingCorrection());
      if (hasUseTypingCorrection()) {
        result = result && (getUseTypingCorrection()
            == other.getUseTypingCorrection());
      }
      result = result && (hasUseDateConversion() == other.hasUseDateConversion());
      if (hasUseDateConversion()) {
        result = result && (getUseDateConversion()
            == other.getUseDateConversion());
      }
      result = result && (hasUseSingleKanjiConversion() == other.hasUseSingleKanjiConversion());
      if (hasUseSingleKanjiConversion()) {
        result = result && (getUseSingleKanjiConversion()
            == other.getUseSingleKanjiConversion());
      }
      result = result && (hasUseSymbolConversion() == other.hasUseSymbolConversion());
      if (hasUseSymbolConversion()) {
        result = result && (getUseSymbolConversion()
            == other.getUseSymbolConversion());
      }
      result = result && (hasUseNumberConversion() == other.hasUseNumberConversion());
      if (hasUseNumberConversion()) {
        result = result && (getUseNumberConversion()
            == other.getUseNumberConversion());
      }
      result = result && (hasUseEmoticonConversion() == other.hasUseEmoticonConversion());
      if (hasUseEmoticonConversion()) {
        result = result && (getUseEmoticonConversion()
            == other.getUseEmoticonConversion());
      }
      result = result && (hasUseCalculator() == other.hasUseCalculator());
      if (hasUseCalculator()) {
        result = result && (getUseCalculator()
            == other.getUseCalculator());
      }
      result = result && (hasUseT13NConversion() == other.hasUseT13NConversion());
      if (hasUseT13NConversion()) {
        result = result && (getUseT13NConversion()
            == other.getUseT13NConversion());
      }
      result = result && (hasUseZipCodeConversion() == other.hasUseZipCodeConversion());
      if (hasUseZipCodeConversion()) {
        result = result && (getUseZipCodeConversion()
            == other.getUseZipCodeConversion());
      }
      result = result && (hasUseSpellingCorrection() == other.hasUseSpellingCorrection());
      if (hasUseSpellingCorrection()) {
        result = result && (getUseSpellingCorrection()
            == other.getUseSpellingCorrection());
      }
      result = result && (hasUseEmojiConversion() == other.hasUseEmojiConversion());
      if (hasUseEmojiConversion()) {
        result = result && (getUseEmojiConversion()
            == other.getUseEmojiConversion());
      }
      result = result && (hasInformationListConfig() == other.hasInformationListConfig());
      if (hasInformationListConfig()) {
        result = result && getInformationListConfig()
            .equals(other.getInformationListConfig());
      }
      result = result && (hasUseHistorySuggest() == other.hasUseHistorySuggest());
      if (hasUseHistorySuggest()) {
        result = result && (getUseHistorySuggest()
            == other.getUseHistorySuggest());
      }
      result = result && (hasUseDictionarySuggest() == other.hasUseDictionarySuggest());
      if (hasUseDictionarySuggest()) {
        result = result && (getUseDictionarySuggest()
            == other.getUseDictionarySuggest());
      }
      result = result && (hasUseRealtimeConversion() == other.hasUseRealtimeConversion());
      if (hasUseRealtimeConversion()) {
        result = result && (getUseRealtimeConversion()
            == other.getUseRealtimeConversion());
      }
      result = result && (hasSuggestionsSize() == other.hasSuggestionsSize());
      if (hasSuggestionsSize()) {
        result = result && (getSuggestionsSize()
            == other.getSuggestionsSize());
      }
      result = result && (hasUseModeIndicator() == other.hasUseModeIndicator());
      if (hasUseModeIndicator()) {
        result = result && (getUseModeIndicator()
            == other.getUseModeIndicator());
      }
      result = result && (hasAllowCloudHandwriting() == other.hasAllowCloudHandwriting());
      if (hasAllowCloudHandwriting()) {
        result = result && (getAllowCloudHandwriting()
            == other.getAllowCloudHandwriting());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasGeneralConfig()) {
        hash = (37 * hash) + GENERAL_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getGeneralConfig().hashCode();
      }
      if (hasVerboseLevel()) {
        hash = (37 * hash) + VERBOSE_LEVEL_FIELD_NUMBER;
        hash = (53 * hash) + getVerboseLevel();
      }
      if (hasIncognitoMode()) {
        hash = (37 * hash) + INCOGNITO_MODE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIncognitoMode());
      }
      if (hasCheckDefault()) {
        hash = (37 * hash) + CHECK_DEFAULT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getCheckDefault());
      }
      if (hasPresentationMode()) {
        hash = (37 * hash) + PRESENTATION_MODE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPresentationMode());
      }
      if (hasPreeditMethod()) {
        hash = (37 * hash) + PREEDIT_METHOD_FIELD_NUMBER;
        hash = (53 * hash) + preeditMethod_;
      }
      if (hasSessionKeymap()) {
        hash = (37 * hash) + SESSION_KEYMAP_FIELD_NUMBER;
        hash = (53 * hash) + sessionKeymap_;
      }
      if (hasCustomKeymapTable()) {
        hash = (37 * hash) + CUSTOM_KEYMAP_TABLE_FIELD_NUMBER;
        hash = (53 * hash) + getCustomKeymapTable().hashCode();
      }
      if (hasCustomRomanTable()) {
        hash = (37 * hash) + CUSTOM_ROMAN_TABLE_FIELD_NUMBER;
        hash = (53 * hash) + getCustomRomanTable().hashCode();
      }
      if (hasPunctuationMethod()) {
        hash = (37 * hash) + PUNCTUATION_METHOD_FIELD_NUMBER;
        hash = (53 * hash) + punctuationMethod_;
      }
      if (hasSymbolMethod()) {
        hash = (37 * hash) + SYMBOL_METHOD_FIELD_NUMBER;
        hash = (53 * hash) + symbolMethod_;
      }
      if (hasSpaceCharacterForm()) {
        hash = (37 * hash) + SPACE_CHARACTER_FORM_FIELD_NUMBER;
        hash = (53 * hash) + spaceCharacterForm_;
      }
      if (hasUseKeyboardToChangePreeditMethod()) {
        hash = (37 * hash) + USE_KEYBOARD_TO_CHANGE_PREEDIT_METHOD_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseKeyboardToChangePreeditMethod());
      }
      if (hasHistoryLearningLevel()) {
        hash = (37 * hash) + HISTORY_LEARNING_LEVEL_FIELD_NUMBER;
        hash = (53 * hash) + historyLearningLevel_;
      }
      if (hasSelectionShortcut()) {
        hash = (37 * hash) + SELECTION_SHORTCUT_FIELD_NUMBER;
        hash = (53 * hash) + selectionShortcut_;
      }
      if (getCharacterFormRulesCount() > 0) {
        hash = (37 * hash) + CHARACTER_FORM_RULES_FIELD_NUMBER;
        hash = (53 * hash) + getCharacterFormRulesList().hashCode();
      }
      if (hasUseAutoImeTurnOff()) {
        hash = (37 * hash) + USE_AUTO_IME_TURN_OFF_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseAutoImeTurnOff());
      }
      if (hasUseCascadingWindow()) {
        hash = (37 * hash) + USE_CASCADING_WINDOW_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseCascadingWindow());
      }
      if (hasShiftKeyModeSwitch()) {
        hash = (37 * hash) + SHIFT_KEY_MODE_SWITCH_FIELD_NUMBER;
        hash = (53 * hash) + shiftKeyModeSwitch_;
      }
      if (hasNumpadCharacterForm()) {
        hash = (37 * hash) + NUMPAD_CHARACTER_FORM_FIELD_NUMBER;
        hash = (53 * hash) + numpadCharacterForm_;
      }
      if (hasUseAutoConversion()) {
        hash = (37 * hash) + USE_AUTO_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseAutoConversion());
      }
      if (hasAutoConversionKey()) {
        hash = (37 * hash) + AUTO_CONVERSION_KEY_FIELD_NUMBER;
        hash = (53 * hash) + getAutoConversionKey();
      }
      if (hasYenSignCharacter()) {
        hash = (37 * hash) + YEN_SIGN_CHARACTER_FIELD_NUMBER;
        hash = (53 * hash) + yenSignCharacter_;
      }
      if (hasUseJapaneseLayout()) {
        hash = (37 * hash) + USE_JAPANESE_LAYOUT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseJapaneseLayout());
      }
      if (hasUseKanaModifierInsensitiveConversion()) {
        hash = (37 * hash) + USE_KANA_MODIFIER_INSENSITIVE_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseKanaModifierInsensitiveConversion());
      }
      if (hasUseTypingCorrection()) {
        hash = (37 * hash) + USE_TYPING_CORRECTION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseTypingCorrection());
      }
      if (hasUseDateConversion()) {
        hash = (37 * hash) + USE_DATE_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseDateConversion());
      }
      if (hasUseSingleKanjiConversion()) {
        hash = (37 * hash) + USE_SINGLE_KANJI_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseSingleKanjiConversion());
      }
      if (hasUseSymbolConversion()) {
        hash = (37 * hash) + USE_SYMBOL_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseSymbolConversion());
      }
      if (hasUseNumberConversion()) {
        hash = (37 * hash) + USE_NUMBER_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseNumberConversion());
      }
      if (hasUseEmoticonConversion()) {
        hash = (37 * hash) + USE_EMOTICON_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseEmoticonConversion());
      }
      if (hasUseCalculator()) {
        hash = (37 * hash) + USE_CALCULATOR_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseCalculator());
      }
      if (hasUseT13NConversion()) {
        hash = (37 * hash) + USE_T13N_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseT13NConversion());
      }
      if (hasUseZipCodeConversion()) {
        hash = (37 * hash) + USE_ZIP_CODE_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseZipCodeConversion());
      }
      if (hasUseSpellingCorrection()) {
        hash = (37 * hash) + USE_SPELLING_CORRECTION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseSpellingCorrection());
      }
      if (hasUseEmojiConversion()) {
        hash = (37 * hash) + USE_EMOJI_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseEmojiConversion());
      }
      if (hasInformationListConfig()) {
        hash = (37 * hash) + INFORMATION_LIST_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getInformationListConfig().hashCode();
      }
      if (hasUseHistorySuggest()) {
        hash = (37 * hash) + USE_HISTORY_SUGGEST_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseHistorySuggest());
      }
      if (hasUseDictionarySuggest()) {
        hash = (37 * hash) + USE_DICTIONARY_SUGGEST_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseDictionarySuggest());
      }
      if (hasUseRealtimeConversion()) {
        hash = (37 * hash) + USE_REALTIME_CONVERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseRealtimeConversion());
      }
      if (hasSuggestionsSize()) {
        hash = (37 * hash) + SUGGESTIONS_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getSuggestionsSize();
      }
      if (hasUseModeIndicator()) {
        hash = (37 * hash) + USE_MODE_INDICATOR_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseModeIndicator());
      }
      if (hasAllowCloudHandwriting()) {
        hash = (37 * hash) + ALLOW_CLOUD_HANDWRITING_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getAllowCloudHandwriting());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code mozc.config.Config}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:mozc.config.Config)
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getGeneralConfigFieldBuilder();
          getCharacterFormRulesFieldBuilder();
          getInformationListConfigFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (generalConfigBuilder_ == null) {
          generalConfig_ = null;
        } else {
          generalConfigBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        verboseLevel_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        incognitoMode_ = false;
        bitField0_ = (bitField0_ & ~0x00000004);
        checkDefault_ = true;
        bitField0_ = (bitField0_ & ~0x00000008);
        presentationMode_ = false;
        bitField0_ = (bitField0_ & ~0x00000010);
        preeditMethod_ = 0;
        bitField0_ = (bitField0_ & ~0x00000020);
        sessionKeymap_ = -1;
        bitField0_ = (bitField0_ & ~0x00000040);
        customKeymapTable_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000080);
        customRomanTable_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000100);
        punctuationMethod_ = 0;
        bitField0_ = (bitField0_ & ~0x00000200);
        symbolMethod_ = 0;
        bitField0_ = (bitField0_ & ~0x00000400);
        spaceCharacterForm_ = 0;
        bitField0_ = (bitField0_ & ~0x00000800);
        useKeyboardToChangePreeditMethod_ = false;
        bitField0_ = (bitField0_ & ~0x00001000);
        historyLearningLevel_ = 0;
        bitField0_ = (bitField0_ & ~0x00002000);
        selectionShortcut_ = 1;
        bitField0_ = (bitField0_ & ~0x00004000);
        if (characterFormRulesBuilder_ == null) {
          characterFormRules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00008000);
        } else {
          characterFormRulesBuilder_.clear();
        }
        useAutoImeTurnOff_ = true;
        bitField0_ = (bitField0_ & ~0x00010000);
        useCascadingWindow_ = true;
        bitField0_ = (bitField0_ & ~0x00020000);
        shiftKeyModeSwitch_ = 1;
        bitField0_ = (bitField0_ & ~0x00040000);
        numpadCharacterForm_ = 2;
        bitField0_ = (bitField0_ & ~0x00080000);
        useAutoConversion_ = false;
        bitField0_ = (bitField0_ & ~0x00100000);
        autoConversionKey_ = 13;
        bitField0_ = (bitField0_ & ~0x00200000);
        yenSignCharacter_ = 0;
        bitField0_ = (bitField0_ & ~0x00400000);
        useJapaneseLayout_ = false;
        bitField0_ = (bitField0_ & ~0x00800000);
        useKanaModifierInsensitiveConversion_ = false;
        bitField0_ = (bitField0_ & ~0x01000000);
        useTypingCorrection_ = false;
        bitField0_ = (bitField0_ & ~0x02000000);
        useDateConversion_ = true;
        bitField0_ = (bitField0_ & ~0x04000000);
        useSingleKanjiConversion_ = true;
        bitField0_ = (bitField0_ & ~0x08000000);
        useSymbolConversion_ = true;
        bitField0_ = (bitField0_ & ~0x10000000);
        useNumberConversion_ = true;
        bitField0_ = (bitField0_ & ~0x20000000);
        useEmoticonConversion_ = true;
        bitField0_ = (bitField0_ & ~0x40000000);
        useCalculator_ = true;
        bitField0_ = (bitField0_ & ~0x80000000);
        useT13NConversion_ = true;
        bitField1_ = (bitField1_ & ~0x00000001);
        useZipCodeConversion_ = true;
        bitField1_ = (bitField1_ & ~0x00000002);
        useSpellingCorrection_ = true;
        bitField1_ = (bitField1_ & ~0x00000004);
        useEmojiConversion_ = false;
        bitField1_ = (bitField1_ & ~0x00000008);
        if (informationListConfigBuilder_ == null) {
          informationListConfig_ = null;
        } else {
          informationListConfigBuilder_.clear();
        }
        bitField1_ = (bitField1_ & ~0x00000010);
        useHistorySuggest_ = true;
        bitField1_ = (bitField1_ & ~0x00000020);
        useDictionarySuggest_ = true;
        bitField1_ = (bitField1_ & ~0x00000040);
        useRealtimeConversion_ = true;
        bitField1_ = (bitField1_ & ~0x00000080);
        suggestionsSize_ = 3;
        bitField1_ = (bitField1_ & ~0x00000100);
        useModeIndicator_ = true;
        bitField1_ = (bitField1_ & ~0x00000200);
        allowCloudHandwriting_ = false;
        bitField1_ = (bitField1_ & ~0x00000400);
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_descriptor;
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance();
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config(this);
        int from_bitField0_ = bitField0_;
        int from_bitField1_ = bitField1_;
        int to_bitField0_ = 0;
        int to_bitField1_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (generalConfigBuilder_ == null) {
          result.generalConfig_ = generalConfig_;
        } else {
          result.generalConfig_ = generalConfigBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.verboseLevel_ = verboseLevel_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.incognitoMode_ = incognitoMode_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.checkDefault_ = checkDefault_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.presentationMode_ = presentationMode_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.preeditMethod_ = preeditMethod_;
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000040;
        }
        result.sessionKeymap_ = sessionKeymap_;
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000080;
        }
        result.customKeymapTable_ = customKeymapTable_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000100;
        }
        result.customRomanTable_ = customRomanTable_;
        if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
          to_bitField0_ |= 0x00000200;
        }
        result.punctuationMethod_ = punctuationMethod_;
        if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
          to_bitField0_ |= 0x00000400;
        }
        result.symbolMethod_ = symbolMethod_;
        if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
          to_bitField0_ |= 0x00000800;
        }
        result.spaceCharacterForm_ = spaceCharacterForm_;
        if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
          to_bitField0_ |= 0x00001000;
        }
        result.useKeyboardToChangePreeditMethod_ = useKeyboardToChangePreeditMethod_;
        if (((from_bitField0_ & 0x00002000) == 0x00002000)) {
          to_bitField0_ |= 0x00002000;
        }
        result.historyLearningLevel_ = historyLearningLevel_;
        if (((from_bitField0_ & 0x00004000) == 0x00004000)) {
          to_bitField0_ |= 0x00004000;
        }
        result.selectionShortcut_ = selectionShortcut_;
        if (characterFormRulesBuilder_ == null) {
          if (((bitField0_ & 0x00008000) == 0x00008000)) {
            characterFormRules_ = java.util.Collections.unmodifiableList(characterFormRules_);
            bitField0_ = (bitField0_ & ~0x00008000);
          }
          result.characterFormRules_ = characterFormRules_;
        } else {
          result.characterFormRules_ = characterFormRulesBuilder_.build();
        }
        if (((from_bitField0_ & 0x00010000) == 0x00010000)) {
          to_bitField0_ |= 0x00008000;
        }
        result.useAutoImeTurnOff_ = useAutoImeTurnOff_;
        if (((from_bitField0_ & 0x00020000) == 0x00020000)) {
          to_bitField0_ |= 0x00010000;
        }
        result.useCascadingWindow_ = useCascadingWindow_;
        if (((from_bitField0_ & 0x00040000) == 0x00040000)) {
          to_bitField0_ |= 0x00020000;
        }
        result.shiftKeyModeSwitch_ = shiftKeyModeSwitch_;
        if (((from_bitField0_ & 0x00080000) == 0x00080000)) {
          to_bitField0_ |= 0x00040000;
        }
        result.numpadCharacterForm_ = numpadCharacterForm_;
        if (((from_bitField0_ & 0x00100000) == 0x00100000)) {
          to_bitField0_ |= 0x00080000;
        }
        result.useAutoConversion_ = useAutoConversion_;
        if (((from_bitField0_ & 0x00200000) == 0x00200000)) {
          to_bitField0_ |= 0x00100000;
        }
        result.autoConversionKey_ = autoConversionKey_;
        if (((from_bitField0_ & 0x00400000) == 0x00400000)) {
          to_bitField0_ |= 0x00200000;
        }
        result.yenSignCharacter_ = yenSignCharacter_;
        if (((from_bitField0_ & 0x00800000) == 0x00800000)) {
          to_bitField0_ |= 0x00400000;
        }
        result.useJapaneseLayout_ = useJapaneseLayout_;
        if (((from_bitField0_ & 0x01000000) == 0x01000000)) {
          to_bitField0_ |= 0x00800000;
        }
        result.useKanaModifierInsensitiveConversion_ = useKanaModifierInsensitiveConversion_;
        if (((from_bitField0_ & 0x02000000) == 0x02000000)) {
          to_bitField0_ |= 0x01000000;
        }
        result.useTypingCorrection_ = useTypingCorrection_;
        if (((from_bitField0_ & 0x04000000) == 0x04000000)) {
          to_bitField0_ |= 0x02000000;
        }
        result.useDateConversion_ = useDateConversion_;
        if (((from_bitField0_ & 0x08000000) == 0x08000000)) {
          to_bitField0_ |= 0x04000000;
        }
        result.useSingleKanjiConversion_ = useSingleKanjiConversion_;
        if (((from_bitField0_ & 0x10000000) == 0x10000000)) {
          to_bitField0_ |= 0x08000000;
        }
        result.useSymbolConversion_ = useSymbolConversion_;
        if (((from_bitField0_ & 0x20000000) == 0x20000000)) {
          to_bitField0_ |= 0x10000000;
        }
        result.useNumberConversion_ = useNumberConversion_;
        if (((from_bitField0_ & 0x40000000) == 0x40000000)) {
          to_bitField0_ |= 0x20000000;
        }
        result.useEmoticonConversion_ = useEmoticonConversion_;
        if (((from_bitField0_ & 0x80000000) == 0x80000000)) {
          to_bitField0_ |= 0x40000000;
        }
        result.useCalculator_ = useCalculator_;
        if (((from_bitField1_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x80000000;
        }
        result.useT13NConversion_ = useT13NConversion_;
        if (((from_bitField1_ & 0x00000002) == 0x00000002)) {
          to_bitField1_ |= 0x00000001;
        }
        result.useZipCodeConversion_ = useZipCodeConversion_;
        if (((from_bitField1_ & 0x00000004) == 0x00000004)) {
          to_bitField1_ |= 0x00000002;
        }
        result.useSpellingCorrection_ = useSpellingCorrection_;
        if (((from_bitField1_ & 0x00000008) == 0x00000008)) {
          to_bitField1_ |= 0x00000004;
        }
        result.useEmojiConversion_ = useEmojiConversion_;
        if (((from_bitField1_ & 0x00000010) == 0x00000010)) {
          to_bitField1_ |= 0x00000008;
        }
        if (informationListConfigBuilder_ == null) {
          result.informationListConfig_ = informationListConfig_;
        } else {
          result.informationListConfig_ = informationListConfigBuilder_.build();
        }
        if (((from_bitField1_ & 0x00000020) == 0x00000020)) {
          to_bitField1_ |= 0x00000010;
        }
        result.useHistorySuggest_ = useHistorySuggest_;
        if (((from_bitField1_ & 0x00000040) == 0x00000040)) {
          to_bitField1_ |= 0x00000020;
        }
        result.useDictionarySuggest_ = useDictionarySuggest_;
        if (((from_bitField1_ & 0x00000080) == 0x00000080)) {
          to_bitField1_ |= 0x00000040;
        }
        result.useRealtimeConversion_ = useRealtimeConversion_;
        if (((from_bitField1_ & 0x00000100) == 0x00000100)) {
          to_bitField1_ |= 0x00000080;
        }
        result.suggestionsSize_ = suggestionsSize_;
        if (((from_bitField1_ & 0x00000200) == 0x00000200)) {
          to_bitField1_ |= 0x00000100;
        }
        result.useModeIndicator_ = useModeIndicator_;
        if (((from_bitField1_ & 0x00000400) == 0x00000400)) {
          to_bitField1_ |= 0x00000200;
        }
        result.allowCloudHandwriting_ = allowCloudHandwriting_;
        result.bitField0_ = to_bitField0_;
        result.bitField1_ = to_bitField1_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance()) return this;
        if (other.hasGeneralConfig()) {
          mergeGeneralConfig(other.getGeneralConfig());
        }
        if (other.hasVerboseLevel()) {
          setVerboseLevel(other.getVerboseLevel());
        }
        if (other.hasIncognitoMode()) {
          setIncognitoMode(other.getIncognitoMode());
        }
        if (other.hasCheckDefault()) {
          setCheckDefault(other.getCheckDefault());
        }
        if (other.hasPresentationMode()) {
          setPresentationMode(other.getPresentationMode());
        }
        if (other.hasPreeditMethod()) {
          setPreeditMethod(other.getPreeditMethod());
        }
        if (other.hasSessionKeymap()) {
          setSessionKeymap(other.getSessionKeymap());
        }
        if (other.hasCustomKeymapTable()) {
          setCustomKeymapTable(other.getCustomKeymapTable());
        }
        if (other.hasCustomRomanTable()) {
          setCustomRomanTable(other.getCustomRomanTable());
        }
        if (other.hasPunctuationMethod()) {
          setPunctuationMethod(other.getPunctuationMethod());
        }
        if (other.hasSymbolMethod()) {
          setSymbolMethod(other.getSymbolMethod());
        }
        if (other.hasSpaceCharacterForm()) {
          setSpaceCharacterForm(other.getSpaceCharacterForm());
        }
        if (other.hasUseKeyboardToChangePreeditMethod()) {
          setUseKeyboardToChangePreeditMethod(other.getUseKeyboardToChangePreeditMethod());
        }
        if (other.hasHistoryLearningLevel()) {
          setHistoryLearningLevel(other.getHistoryLearningLevel());
        }
        if (other.hasSelectionShortcut()) {
          setSelectionShortcut(other.getSelectionShortcut());
        }
        if (characterFormRulesBuilder_ == null) {
          if (!other.characterFormRules_.isEmpty()) {
            if (characterFormRules_.isEmpty()) {
              characterFormRules_ = other.characterFormRules_;
              bitField0_ = (bitField0_ & ~0x00008000);
            } else {
              ensureCharacterFormRulesIsMutable();
              characterFormRules_.addAll(other.characterFormRules_);
            }
            onChanged();
          }
        } else {
          if (!other.characterFormRules_.isEmpty()) {
            if (characterFormRulesBuilder_.isEmpty()) {
              characterFormRulesBuilder_.dispose();
              characterFormRulesBuilder_ = null;
              characterFormRules_ = other.characterFormRules_;
              bitField0_ = (bitField0_ & ~0x00008000);
              characterFormRulesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getCharacterFormRulesFieldBuilder() : null;
            } else {
              characterFormRulesBuilder_.addAllMessages(other.characterFormRules_);
            }
          }
        }
        if (other.hasUseAutoImeTurnOff()) {
          setUseAutoImeTurnOff(other.getUseAutoImeTurnOff());
        }
        if (other.hasUseCascadingWindow()) {
          setUseCascadingWindow(other.getUseCascadingWindow());
        }
        if (other.hasShiftKeyModeSwitch()) {
          setShiftKeyModeSwitch(other.getShiftKeyModeSwitch());
        }
        if (other.hasNumpadCharacterForm()) {
          setNumpadCharacterForm(other.getNumpadCharacterForm());
        }
        if (other.hasUseAutoConversion()) {
          setUseAutoConversion(other.getUseAutoConversion());
        }
        if (other.hasAutoConversionKey()) {
          setAutoConversionKey(other.getAutoConversionKey());
        }
        if (other.hasYenSignCharacter()) {
          setYenSignCharacter(other.getYenSignCharacter());
        }
        if (other.hasUseJapaneseLayout()) {
          setUseJapaneseLayout(other.getUseJapaneseLayout());
        }
        if (other.hasUseKanaModifierInsensitiveConversion()) {
          setUseKanaModifierInsensitiveConversion(other.getUseKanaModifierInsensitiveConversion());
        }
        if (other.hasUseTypingCorrection()) {
          setUseTypingCorrection(other.getUseTypingCorrection());
        }
        if (other.hasUseDateConversion()) {
          setUseDateConversion(other.getUseDateConversion());
        }
        if (other.hasUseSingleKanjiConversion()) {
          setUseSingleKanjiConversion(other.getUseSingleKanjiConversion());
        }
        if (other.hasUseSymbolConversion()) {
          setUseSymbolConversion(other.getUseSymbolConversion());
        }
        if (other.hasUseNumberConversion()) {
          setUseNumberConversion(other.getUseNumberConversion());
        }
        if (other.hasUseEmoticonConversion()) {
          setUseEmoticonConversion(other.getUseEmoticonConversion());
        }
        if (other.hasUseCalculator()) {
          setUseCalculator(other.getUseCalculator());
        }
        if (other.hasUseT13NConversion()) {
          setUseT13NConversion(other.getUseT13NConversion());
        }
        if (other.hasUseZipCodeConversion()) {
          setUseZipCodeConversion(other.getUseZipCodeConversion());
        }
        if (other.hasUseSpellingCorrection()) {
          setUseSpellingCorrection(other.getUseSpellingCorrection());
        }
        if (other.hasUseEmojiConversion()) {
          setUseEmojiConversion(other.getUseEmojiConversion());
        }
        if (other.hasInformationListConfig()) {
          mergeInformationListConfig(other.getInformationListConfig());
        }
        if (other.hasUseHistorySuggest()) {
          setUseHistorySuggest(other.getUseHistorySuggest());
        }
        if (other.hasUseDictionarySuggest()) {
          setUseDictionarySuggest(other.getUseDictionarySuggest());
        }
        if (other.hasUseRealtimeConversion()) {
          setUseRealtimeConversion(other.getUseRealtimeConversion());
        }
        if (other.hasSuggestionsSize()) {
          setSuggestionsSize(other.getSuggestionsSize());
        }
        if (other.hasUseModeIndicator()) {
          setUseModeIndicator(other.getUseModeIndicator());
        }
        if (other.hasAllowCloudHandwriting()) {
          setAllowCloudHandwriting(other.getAllowCloudHandwriting());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;
      private int bitField1_;

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig generalConfig_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder> generalConfigBuilder_;
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public boolean hasGeneralConfig() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getGeneralConfig() {
        if (generalConfigBuilder_ == null) {
          return generalConfig_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance() : generalConfig_;
        } else {
          return generalConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public Builder setGeneralConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig value) {
        if (generalConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          generalConfig_ = value;
          onChanged();
        } else {
          generalConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public Builder setGeneralConfig(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder builderForValue) {
        if (generalConfigBuilder_ == null) {
          generalConfig_ = builderForValue.build();
          onChanged();
        } else {
          generalConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public Builder mergeGeneralConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig value) {
        if (generalConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              generalConfig_ != null &&
              generalConfig_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance()) {
            generalConfig_ =
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.newBuilder(generalConfig_).mergeFrom(value).buildPartial();
          } else {
            generalConfig_ = value;
          }
          onChanged();
        } else {
          generalConfigBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public Builder clearGeneralConfig() {
        if (generalConfigBuilder_ == null) {
          generalConfig_ = null;
          onChanged();
        } else {
          generalConfigBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder getGeneralConfigBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getGeneralConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder getGeneralConfigOrBuilder() {
        if (generalConfigBuilder_ != null) {
          return generalConfigBuilder_.getMessageOrBuilder();
        } else {
          return generalConfig_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance() : generalConfig_;
        }
      }
      /**
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       *
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder> 
          getGeneralConfigFieldBuilder() {
        if (generalConfigBuilder_ == null) {
          generalConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder>(
                  getGeneralConfig(),
                  getParentForChildren(),
                  isClean());
          generalConfig_ = null;
        }
        return generalConfigBuilder_;
      }

      private int verboseLevel_ ;
      /**
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       *
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       */
      public boolean hasVerboseLevel() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       *
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       */
      public int getVerboseLevel() {
        return verboseLevel_;
      }
      /**
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       *
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       */
      public Builder setVerboseLevel(int value) {
        bitField0_ |= 0x00000002;
        verboseLevel_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       *
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       */
      public Builder clearVerboseLevel() {
        bitField0_ = (bitField0_ & ~0x00000002);
        verboseLevel_ = 0;
        onChanged();
        return this;
      }

      private boolean incognitoMode_ ;
      /**
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * </pre>
       *
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       */
      public boolean hasIncognitoMode() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * </pre>
       *
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       */
      public boolean getIncognitoMode() {
        return incognitoMode_;
      }
      /**
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * </pre>
       *
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       */
      public Builder setIncognitoMode(boolean value) {
        bitField0_ |= 0x00000004;
        incognitoMode_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * </pre>
       *
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       */
      public Builder clearIncognitoMode() {
        bitField0_ = (bitField0_ & ~0x00000004);
        incognitoMode_ = false;
        onChanged();
        return this;
      }

      private boolean checkDefault_ = true;
      /**
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       *
       * <code>optional bool check_default = 22 [default = true];</code>
       */
      public boolean hasCheckDefault() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       *
       * <code>optional bool check_default = 22 [default = true];</code>
       */
      public boolean getCheckDefault() {
        return checkDefault_;
      }
      /**
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       *
       * <code>optional bool check_default = 22 [default = true];</code>
       */
      public Builder setCheckDefault(boolean value) {
        bitField0_ |= 0x00000008;
        checkDefault_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       *
       * <code>optional bool check_default = 22 [default = true];</code>
       */
      public Builder clearCheckDefault() {
        bitField0_ = (bitField0_ & ~0x00000008);
        checkDefault_ = true;
        onChanged();
        return this;
      }

      private boolean presentationMode_ ;
      /**
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       *
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       */
      public boolean hasPresentationMode() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       *
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       */
      public boolean getPresentationMode() {
        return presentationMode_;
      }
      /**
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       *
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       */
      public Builder setPresentationMode(boolean value) {
        bitField0_ |= 0x00000010;
        presentationMode_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       *
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       */
      public Builder clearPresentationMode() {
        bitField0_ = (bitField0_ & ~0x00000010);
        presentationMode_ = false;
        onChanged();
        return this;
      }

      private int preeditMethod_ = 0;
      /**
       * <pre>
       * Roman/Kana
       * </pre>
       *
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       */
      public boolean hasPreeditMethod() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <pre>
       * Roman/Kana
       * </pre>
       *
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod getPreeditMethod() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.valueOf(preeditMethod_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.ROMAN : result;
      }
      /**
       * <pre>
       * Roman/Kana
       * </pre>
       *
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       */
      public Builder setPreeditMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000020;
        preeditMethod_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Roman/Kana
       * </pre>
       *
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       */
      public Builder clearPreeditMethod() {
        bitField0_ = (bitField0_ & ~0x00000020);
        preeditMethod_ = 0;
        onChanged();
        return this;
      }

      private int sessionKeymap_ = -1;
      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       */
      public boolean hasSessionKeymap() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getSessionKeymap() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.valueOf(sessionKeymap_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.NONE : result;
      }
      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       */
      public Builder setSessionKeymap(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000040;
        sessionKeymap_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       */
      public Builder clearSessionKeymap() {
        bitField0_ = (bitField0_ & ~0x00000040);
        sessionKeymap_ = -1;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString customKeymapTable_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       *
       * <code>optional bytes custom_keymap_table = 42;</code>
       */
      public boolean hasCustomKeymapTable() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       *
       * <code>optional bytes custom_keymap_table = 42;</code>
       */
      public com.google.protobuf.ByteString getCustomKeymapTable() {
        return customKeymapTable_;
      }
      /**
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       *
       * <code>optional bytes custom_keymap_table = 42;</code>
       */
      public Builder setCustomKeymapTable(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        customKeymapTable_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       *
       * <code>optional bytes custom_keymap_table = 42;</code>
       */
      public Builder clearCustomKeymapTable() {
        bitField0_ = (bitField0_ & ~0x00000080);
        customKeymapTable_ = getDefaultInstance().getCustomKeymapTable();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString customRomanTable_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * custom roman table
       * </pre>
       *
       * <code>optional bytes custom_roman_table = 43;</code>
       */
      public boolean hasCustomRomanTable() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <pre>
       * custom roman table
       * </pre>
       *
       * <code>optional bytes custom_roman_table = 43;</code>
       */
      public com.google.protobuf.ByteString getCustomRomanTable() {
        return customRomanTable_;
      }
      /**
       * <pre>
       * custom roman table
       * </pre>
       *
       * <code>optional bytes custom_roman_table = 43;</code>
       */
      public Builder setCustomRomanTable(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000100;
        customRomanTable_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * custom roman table
       * </pre>
       *
       * <code>optional bytes custom_roman_table = 43;</code>
       */
      public Builder clearCustomRomanTable() {
        bitField0_ = (bitField0_ & ~0x00000100);
        customRomanTable_ = getDefaultInstance().getCustomRomanTable();
        onChanged();
        return this;
      }

      private int punctuationMethod_ = 0;
      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
       */
      public boolean hasPunctuationMethod() {
        return ((bitField0_ & 0x00000200) == 0x00000200);
      }
      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod getPunctuationMethod() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.valueOf(punctuationMethod_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.KUTEN_TOUTEN : result;
      }
      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
       */
      public Builder setPunctuationMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000200;
        punctuationMethod_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
       */
      public Builder clearPunctuationMethod() {
        bitField0_ = (bitField0_ & ~0x00000200);
        punctuationMethod_ = 0;
        onChanged();
        return this;
      }

      private int symbolMethod_ = 0;
      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       */
      public boolean hasSymbolMethod() {
        return ((bitField0_ & 0x00000400) == 0x00000400);
      }
      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod getSymbolMethod() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.valueOf(symbolMethod_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.CORNER_BRACKET_MIDDLE_DOT : result;
      }
      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       */
      public Builder setSymbolMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000400;
        symbolMethod_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       */
      public Builder clearSymbolMethod() {
        bitField0_ = (bitField0_ & ~0x00000400);
        symbolMethod_ = 0;
        onChanged();
        return this;
      }

      private int spaceCharacterForm_ = 0;
      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       */
      public boolean hasSpaceCharacterForm() {
        return ((bitField0_ & 0x00000800) == 0x00000800);
      }
      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm getSpaceCharacterForm() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.valueOf(spaceCharacterForm_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.FUNDAMENTAL_INPUT_MODE : result;
      }
      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       */
      public Builder setSpaceCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000800;
        spaceCharacterForm_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       */
      public Builder clearSpaceCharacterForm() {
        bitField0_ = (bitField0_ & ~0x00000800);
        spaceCharacterForm_ = 0;
        onChanged();
        return this;
      }

      private boolean useKeyboardToChangePreeditMethod_ ;
      /**
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       *
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       */
      public boolean hasUseKeyboardToChangePreeditMethod() {
        return ((bitField0_ & 0x00001000) == 0x00001000);
      }
      /**
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       *
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       */
      public boolean getUseKeyboardToChangePreeditMethod() {
        return useKeyboardToChangePreeditMethod_;
      }
      /**
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       *
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       */
      public Builder setUseKeyboardToChangePreeditMethod(boolean value) {
        bitField0_ |= 0x00001000;
        useKeyboardToChangePreeditMethod_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       *
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       */
      public Builder clearUseKeyboardToChangePreeditMethod() {
        bitField0_ = (bitField0_ & ~0x00001000);
        useKeyboardToChangePreeditMethod_ = false;
        onChanged();
        return this;
      }

      private int historyLearningLevel_ = 0;
      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       */
      public boolean hasHistoryLearningLevel() {
        return ((bitField0_ & 0x00002000) == 0x00002000);
      }
      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel getHistoryLearningLevel() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.valueOf(historyLearningLevel_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.DEFAULT_HISTORY : result;
      }
      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       */
      public Builder setHistoryLearningLevel(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00002000;
        historyLearningLevel_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       */
      public Builder clearHistoryLearningLevel() {
        bitField0_ = (bitField0_ & ~0x00002000);
        historyLearningLevel_ = 0;
        onChanged();
        return this;
      }

      private int selectionShortcut_ = 1;
      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       */
      public boolean hasSelectionShortcut() {
        return ((bitField0_ & 0x00004000) == 0x00004000);
      }
      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut getSelectionShortcut() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.valueOf(selectionShortcut_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.SHORTCUT_123456789 : result;
      }
      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       */
      public Builder setSelectionShortcut(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00004000;
        selectionShortcut_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       */
      public Builder clearSelectionShortcut() {
        bitField0_ = (bitField0_ & ~0x00004000);
        selectionShortcut_ = 1;
        onChanged();
        return this;
      }

      private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> characterFormRules_ =
        java.util.Collections.emptyList();
      private void ensureCharacterFormRulesIsMutable() {
        if (!((bitField0_ & 0x00008000) == 0x00008000)) {
          characterFormRules_ = new java.util.ArrayList<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule>(characterFormRules_);
          bitField0_ |= 0x00008000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> characterFormRulesBuilder_;

      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> getCharacterFormRulesList() {
        if (characterFormRulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(characterFormRules_);
        } else {
          return characterFormRulesBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public int getCharacterFormRulesCount() {
        if (characterFormRulesBuilder_ == null) {
          return characterFormRules_.size();
        } else {
          return characterFormRulesBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getCharacterFormRules(int index) {
        if (characterFormRulesBuilder_ == null) {
          return characterFormRules_.get(index);
        } else {
          return characterFormRulesBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder setCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule value) {
        if (characterFormRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.set(index, value);
          onChanged();
        } else {
          characterFormRulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder setCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder builderForValue) {
        if (characterFormRulesBuilder_ == null) {
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.set(index, builderForValue.build());
          onChanged();
        } else {
          characterFormRulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule value) {
        if (characterFormRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.add(value);
          onChanged();
        } else {
          characterFormRulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule value) {
        if (characterFormRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.add(index, value);
          onChanged();
        } else {
          characterFormRulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder builderForValue) {
        if (characterFormRulesBuilder_ == null) {
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.add(builderForValue.build());
          onChanged();
        } else {
          characterFormRulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder builderForValue) {
        if (characterFormRulesBuilder_ == null) {
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.add(index, builderForValue.build());
          onChanged();
        } else {
          characterFormRulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addAllCharacterFormRules(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> values) {
        if (characterFormRulesBuilder_ == null) {
          ensureCharacterFormRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, characterFormRules_);
          onChanged();
        } else {
          characterFormRulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder clearCharacterFormRules() {
        if (characterFormRulesBuilder_ == null) {
          characterFormRules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00008000);
          onChanged();
        } else {
          characterFormRulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder removeCharacterFormRules(int index) {
        if (characterFormRulesBuilder_ == null) {
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.remove(index);
          onChanged();
        } else {
          characterFormRulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder getCharacterFormRulesBuilder(
          int index) {
        return getCharacterFormRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder getCharacterFormRulesOrBuilder(
          int index) {
        if (characterFormRulesBuilder_ == null) {
          return characterFormRules_.get(index);  } else {
          return characterFormRulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> 
           getCharacterFormRulesOrBuilderList() {
        if (characterFormRulesBuilder_ != null) {
          return characterFormRulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(characterFormRules_);
        }
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder addCharacterFormRulesBuilder() {
        return getCharacterFormRulesFieldBuilder().addBuilder(
            org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.getDefaultInstance());
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder addCharacterFormRulesBuilder(
          int index) {
        return getCharacterFormRulesFieldBuilder().addBuilder(
            index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.getDefaultInstance());
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder> 
           getCharacterFormRulesBuilderList() {
        return getCharacterFormRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> 
          getCharacterFormRulesFieldBuilder() {
        if (characterFormRulesBuilder_ == null) {
          characterFormRulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder>(
                  characterFormRules_,
                  ((bitField0_ & 0x00008000) == 0x00008000),
                  getParentForChildren(),
                  isClean());
          characterFormRules_ = null;
        }
        return characterFormRulesBuilder_;
      }

      private boolean useAutoImeTurnOff_ = true;
      /**
       * <pre>
       * auto IME turn off feature
       * </pre>
       *
       * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
       */
      public boolean hasUseAutoImeTurnOff() {
        return ((bitField0_ & 0x00010000) == 0x00010000);
      }
      /**
       * <pre>
       * auto IME turn off feature
       * </pre>
       *
       * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
       */
      public boolean getUseAutoImeTurnOff() {
        return useAutoImeTurnOff_;
      }
      /**
       * <pre>
       * auto IME turn off feature
       * </pre>
       *
       * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
       */
      public Builder setUseAutoImeTurnOff(boolean value) {
        bitField0_ |= 0x00010000;
        useAutoImeTurnOff_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * auto IME turn off feature
       * </pre>
       *
       * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
       */
      public Builder clearUseAutoImeTurnOff() {
        bitField0_ = (bitField0_ & ~0x00010000);
        useAutoImeTurnOff_ = true;
        onChanged();
        return this;
      }

      private boolean useCascadingWindow_ = true;
      /**
       * <pre>
       * Toggle to use cascanding window for debuging.
       * </pre>
       *
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       */
      public boolean hasUseCascadingWindow() {
        return ((bitField0_ & 0x00020000) == 0x00020000);
      }
      /**
       * <pre>
       * Toggle to use cascanding window for debuging.
       * </pre>
       *
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       */
      public boolean getUseCascadingWindow() {
        return useCascadingWindow_;
      }
      /**
       * <pre>
       * Toggle to use cascanding window for debuging.
       * </pre>
       *
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       */
      public Builder setUseCascadingWindow(boolean value) {
        bitField0_ |= 0x00020000;
        useCascadingWindow_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Toggle to use cascanding window for debuging.
       * </pre>
       *
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       */
      public Builder clearUseCascadingWindow() {
        bitField0_ = (bitField0_ & ~0x00020000);
        useCascadingWindow_ = true;
        onChanged();
        return this;
      }

      private int shiftKeyModeSwitch_ = 1;
      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       */
      public boolean hasShiftKeyModeSwitch() {
        return ((bitField0_ & 0x00040000) == 0x00040000);
      }
      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch getShiftKeyModeSwitch() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.valueOf(shiftKeyModeSwitch_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.ASCII_INPUT_MODE : result;
      }
      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       */
      public Builder setShiftKeyModeSwitch(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00040000;
        shiftKeyModeSwitch_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       */
      public Builder clearShiftKeyModeSwitch() {
        bitField0_ = (bitField0_ & ~0x00040000);
        shiftKeyModeSwitch_ = 1;
        onChanged();
        return this;
      }

      private int numpadCharacterForm_ = 2;
      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       */
      public boolean hasNumpadCharacterForm() {
        return ((bitField0_ & 0x00080000) == 0x00080000);
      }
      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm getNumpadCharacterForm() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.valueOf(numpadCharacterForm_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.NUMPAD_HALF_WIDTH : result;
      }
      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       */
      public Builder setNumpadCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00080000;
        numpadCharacterForm_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       */
      public Builder clearNumpadCharacterForm() {
        bitField0_ = (bitField0_ & ~0x00080000);
        numpadCharacterForm_ = 2;
        onChanged();
        return this;
      }

      private boolean useAutoConversion_ ;
      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       */
      public boolean hasUseAutoConversion() {
        return ((bitField0_ & 0x00100000) == 0x00100000);
      }
      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       */
      public boolean getUseAutoConversion() {
        return useAutoConversion_;
      }
      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       */
      public Builder setUseAutoConversion(boolean value) {
        bitField0_ |= 0x00100000;
        useAutoConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       */
      public Builder clearUseAutoConversion() {
        bitField0_ = (bitField0_ & ~0x00100000);
        useAutoConversion_ = false;
        onChanged();
        return this;
      }

      private int autoConversionKey_ = 13;
      /**
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       *
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       */
      public boolean hasAutoConversionKey() {
        return ((bitField0_ & 0x00200000) == 0x00200000);
      }
      /**
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       *
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       */
      public int getAutoConversionKey() {
        return autoConversionKey_;
      }
      /**
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       *
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       */
      public Builder setAutoConversionKey(int value) {
        bitField0_ |= 0x00200000;
        autoConversionKey_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       *
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       */
      public Builder clearAutoConversionKey() {
        bitField0_ = (bitField0_ & ~0x00200000);
        autoConversionKey_ = 13;
        onChanged();
        return this;
      }

      private int yenSignCharacter_ = 0;
      /**
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       *
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       */
      public boolean hasYenSignCharacter() {
        return ((bitField0_ & 0x00400000) == 0x00400000);
      }
      /**
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       *
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter getYenSignCharacter() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter result = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.valueOf(yenSignCharacter_);
        return result == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.YEN_SIGN : result;
      }
      /**
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       *
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       */
      public Builder setYenSignCharacter(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00400000;
        yenSignCharacter_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       *
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       */
      public Builder clearYenSignCharacter() {
        bitField0_ = (bitField0_ & ~0x00400000);
        yenSignCharacter_ = 0;
        onChanged();
        return this;
      }

      private boolean useJapaneseLayout_ ;
      /**
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       *
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       */
      public boolean hasUseJapaneseLayout() {
        return ((bitField0_ & 0x00800000) == 0x00800000);
      }
      /**
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       *
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       */
      public boolean getUseJapaneseLayout() {
        return useJapaneseLayout_;
      }
      /**
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       *
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       */
      public Builder setUseJapaneseLayout(boolean value) {
        bitField0_ |= 0x00800000;
        useJapaneseLayout_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       *
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       */
      public Builder clearUseJapaneseLayout() {
        bitField0_ = (bitField0_ & ~0x00800000);
        useJapaneseLayout_ = false;
        onChanged();
        return this;
      }

      private boolean useKanaModifierInsensitiveConversion_ ;
      /**
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       *
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       */
      public boolean hasUseKanaModifierInsensitiveConversion() {
        return ((bitField0_ & 0x01000000) == 0x01000000);
      }
      /**
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       *
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       */
      public boolean getUseKanaModifierInsensitiveConversion() {
        return useKanaModifierInsensitiveConversion_;
      }
      /**
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       *
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       */
      public Builder setUseKanaModifierInsensitiveConversion(boolean value) {
        bitField0_ |= 0x01000000;
        useKanaModifierInsensitiveConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       *
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       */
      public Builder clearUseKanaModifierInsensitiveConversion() {
        bitField0_ = (bitField0_ & ~0x01000000);
        useKanaModifierInsensitiveConversion_ = false;
        onChanged();
        return this;
      }

      private boolean useTypingCorrection_ ;
      /**
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       *
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       */
      public boolean hasUseTypingCorrection() {
        return ((bitField0_ & 0x02000000) == 0x02000000);
      }
      /**
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       *
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       */
      public boolean getUseTypingCorrection() {
        return useTypingCorrection_;
      }
      /**
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       *
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       */
      public Builder setUseTypingCorrection(boolean value) {
        bitField0_ |= 0x02000000;
        useTypingCorrection_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       *
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       */
      public Builder clearUseTypingCorrection() {
        bitField0_ = (bitField0_ & ~0x02000000);
        useTypingCorrection_ = false;
        onChanged();
        return this;
      }

      private boolean useDateConversion_ = true;
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Dictionary (80-99)
       * </pre>
       *
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       */
      public boolean hasUseDateConversion() {
        return ((bitField0_ & 0x04000000) == 0x04000000);
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Dictionary (80-99)
       * </pre>
       *
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       */
      public boolean getUseDateConversion() {
        return useDateConversion_;
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Dictionary (80-99)
       * </pre>
       *
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       */
      public Builder setUseDateConversion(boolean value) {
        bitField0_ |= 0x04000000;
        useDateConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Dictionary (80-99)
       * </pre>
       *
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       */
      public Builder clearUseDateConversion() {
        bitField0_ = (bitField0_ & ~0x04000000);
        useDateConversion_ = true;
        onChanged();
        return this;
      }

      private boolean useSingleKanjiConversion_ = true;
      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       */
      public boolean hasUseSingleKanjiConversion() {
        return ((bitField0_ & 0x08000000) == 0x08000000);
      }
      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       */
      public boolean getUseSingleKanjiConversion() {
        return useSingleKanjiConversion_;
      }
      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       */
      public Builder setUseSingleKanjiConversion(boolean value) {
        bitField0_ |= 0x08000000;
        useSingleKanjiConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       */
      public Builder clearUseSingleKanjiConversion() {
        bitField0_ = (bitField0_ & ~0x08000000);
        useSingleKanjiConversion_ = true;
        onChanged();
        return this;
      }

      private boolean useSymbolConversion_ = true;
      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       */
      public boolean hasUseSymbolConversion() {
        return ((bitField0_ & 0x10000000) == 0x10000000);
      }
      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       */
      public boolean getUseSymbolConversion() {
        return useSymbolConversion_;
      }
      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       */
      public Builder setUseSymbolConversion(boolean value) {
        bitField0_ |= 0x10000000;
        useSymbolConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       */
      public Builder clearUseSymbolConversion() {
        bitField0_ = (bitField0_ & ~0x10000000);
        useSymbolConversion_ = true;
        onChanged();
        return this;
      }

      private boolean useNumberConversion_ = true;
      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       */
      public boolean hasUseNumberConversion() {
        return ((bitField0_ & 0x20000000) == 0x20000000);
      }
      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       */
      public boolean getUseNumberConversion() {
        return useNumberConversion_;
      }
      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       */
      public Builder setUseNumberConversion(boolean value) {
        bitField0_ |= 0x20000000;
        useNumberConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       */
      public Builder clearUseNumberConversion() {
        bitField0_ = (bitField0_ & ~0x20000000);
        useNumberConversion_ = true;
        onChanged();
        return this;
      }

      private boolean useEmoticonConversion_ = true;
      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       */
      public boolean hasUseEmoticonConversion() {
        return ((bitField0_ & 0x40000000) == 0x40000000);
      }
      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       */
      public boolean getUseEmoticonConversion() {
        return useEmoticonConversion_;
      }
      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       */
      public Builder setUseEmoticonConversion(boolean value) {
        bitField0_ |= 0x40000000;
        useEmoticonConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       */
      public Builder clearUseEmoticonConversion() {
        bitField0_ = (bitField0_ & ~0x40000000);
        useEmoticonConversion_ = true;
        onChanged();
        return this;
      }

      private boolean useCalculator_ = true;
      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       */
      public boolean hasUseCalculator() {
        return ((bitField0_ & 0x80000000) == 0x80000000);
      }
      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       */
      public boolean getUseCalculator() {
        return useCalculator_;
      }
      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       */
      public Builder setUseCalculator(boolean value) {
        bitField0_ |= 0x80000000;
        useCalculator_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       */
      public Builder clearUseCalculator() {
        bitField0_ = (bitField0_ & ~0x80000000);
        useCalculator_ = true;
        onChanged();
        return this;
      }

      private boolean useT13NConversion_ = true;
      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       */
      public boolean hasUseT13NConversion() {
        return ((bitField1_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       */
      public boolean getUseT13NConversion() {
        return useT13NConversion_;
      }
      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       */
      public Builder setUseT13NConversion(boolean value) {
        bitField1_ |= 0x00000001;
        useT13NConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       */
      public Builder clearUseT13NConversion() {
        bitField1_ = (bitField1_ & ~0x00000001);
        useT13NConversion_ = true;
        onChanged();
        return this;
      }

      private boolean useZipCodeConversion_ = true;
      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       */
      public boolean hasUseZipCodeConversion() {
        return ((bitField1_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       */
      public boolean getUseZipCodeConversion() {
        return useZipCodeConversion_;
      }
      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       */
      public Builder setUseZipCodeConversion(boolean value) {
        bitField1_ |= 0x00000002;
        useZipCodeConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       */
      public Builder clearUseZipCodeConversion() {
        bitField1_ = (bitField1_ & ~0x00000002);
        useZipCodeConversion_ = true;
        onChanged();
        return this;
      }

      private boolean useSpellingCorrection_ = true;
      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       */
      public boolean hasUseSpellingCorrection() {
        return ((bitField1_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       */
      public boolean getUseSpellingCorrection() {
        return useSpellingCorrection_;
      }
      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       */
      public Builder setUseSpellingCorrection(boolean value) {
        bitField1_ |= 0x00000004;
        useSpellingCorrection_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       */
      public Builder clearUseSpellingCorrection() {
        bitField1_ = (bitField1_ & ~0x00000004);
        useSpellingCorrection_ = true;
        onChanged();
        return this;
      }

      private boolean useEmojiConversion_ ;
      /**
       * <pre>
       * If use_emoji_conversion is true, the user can input emoji characters
       * by converting from a query string (e.g. "  " [U+1F436]).
       * Even if it is false, users might be able to input emoji characters
       * with other ways.
       * Note: Some characters can be either of text and emoji.  It would be ideal
       * to use the variation sequence to specify emoji presentation [U+FE0E],
       * although it is not implemented yet.
       * See: http://unicode.org/reports/tr51/#Presentation_Style
       * </pre>
       *
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       */
      public boolean hasUseEmojiConversion() {
        return ((bitField1_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * If use_emoji_conversion is true, the user can input emoji characters
       * by converting from a query string (e.g. "  " [U+1F436]).
       * Even if it is false, users might be able to input emoji characters
       * with other ways.
       * Note: Some characters can be either of text and emoji.  It would be ideal
       * to use the variation sequence to specify emoji presentation [U+FE0E],
       * although it is not implemented yet.
       * See: http://unicode.org/reports/tr51/#Presentation_Style
       * </pre>
       *
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       */
      public boolean getUseEmojiConversion() {
        return useEmojiConversion_;
      }
      /**
       * <pre>
       * If use_emoji_conversion is true, the user can input emoji characters
       * by converting from a query string (e.g. "  " [U+1F436]).
       * Even if it is false, users might be able to input emoji characters
       * with other ways.
       * Note: Some characters can be either of text and emoji.  It would be ideal
       * to use the variation sequence to specify emoji presentation [U+FE0E],
       * although it is not implemented yet.
       * See: http://unicode.org/reports/tr51/#Presentation_Style
       * </pre>
       *
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       */
      public Builder setUseEmojiConversion(boolean value) {
        bitField1_ |= 0x00000008;
        useEmojiConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If use_emoji_conversion is true, the user can input emoji characters
       * by converting from a query string (e.g. "  " [U+1F436]).
       * Even if it is false, users might be able to input emoji characters
       * with other ways.
       * Note: Some characters can be either of text and emoji.  It would be ideal
       * to use the variation sequence to specify emoji presentation [U+FE0E],
       * although it is not implemented yet.
       * See: http://unicode.org/reports/tr51/#Presentation_Style
       * </pre>
       *
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       */
      public Builder clearUseEmojiConversion() {
        bitField1_ = (bitField1_ & ~0x00000008);
        useEmojiConversion_ = false;
        onChanged();
        return this;
      }

      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig informationListConfig_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder> informationListConfigBuilder_;
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public boolean hasInformationListConfig() {
        return ((bitField1_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getInformationListConfig() {
        if (informationListConfigBuilder_ == null) {
          return informationListConfig_ == null ? org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance() : informationListConfig_;
        } else {
          return informationListConfigBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder setInformationListConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig value) {
        if (informationListConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          informationListConfig_ = value;
          onChanged();
        } else {
          informationListConfigBuilder_.setMessage(value);
        }
        bitField1_ |= 0x00000010;
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder setInformationListConfig(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder builderForValue) {
        if (informationListConfigBuilder_ == null) {
          informationListConfig_ = builderForValue.build();
          onChanged();
        } else {
          informationListConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField1_ |= 0x00000010;
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder mergeInformationListConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig value) {
        if (informationListConfigBuilder_ == null) {
          if (((bitField1_ & 0x00000010) == 0x00000010) &&
              informationListConfig_ != null &&
              informationListConfig_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance()) {
            informationListConfig_ =
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.newBuilder(informationListConfig_).mergeFrom(value).buildPartial();
          } else {
            informationListConfig_ = value;
          }
          onChanged();
        } else {
          informationListConfigBuilder_.mergeFrom(value);
        }
        bitField1_ |= 0x00000010;
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder clearInformationListConfig() {
        if (informationListConfigBuilder_ == null) {
          informationListConfig_ = null;
          onChanged();
        } else {
          informationListConfigBuilder_.clear();
        }
        bitField1_ = (bitField1_ & ~0x00000010);
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder getInformationListConfigBuilder() {
        bitField1_ |= 0x00000010;
        onChanged();
        return getInformationListConfigFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder getInformationListConfigOrBuilder() {
        if (informationListConfigBuilder_ != null) {
          return informationListConfigBuilder_.getMessageOrBuilder();
        } else {
          return informationListConfig_ == null ?
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance() : informationListConfig_;
        }
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder> 
          getInformationListConfigFieldBuilder() {
        if (informationListConfigBuilder_ == null) {
          informationListConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder>(
                  getInformationListConfig(),
                  getParentForChildren(),
                  isClean());
          informationListConfig_ = null;
        }
        return informationListConfigBuilder_;
      }

      private boolean useHistorySuggest_ = true;
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Suggest (100-119)
       * Use history-based suggest feature.
       * </pre>
       *
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       */
      public boolean hasUseHistorySuggest() {
        return ((bitField1_ & 0x00000020) == 0x00000020);
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Suggest (100-119)
       * Use history-based suggest feature.
       * </pre>
       *
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       */
      public boolean getUseHistorySuggest() {
        return useHistorySuggest_;
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Suggest (100-119)
       * Use history-based suggest feature.
       * </pre>
       *
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       */
      public Builder setUseHistorySuggest(boolean value) {
        bitField1_ |= 0x00000020;
        useHistorySuggest_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Suggest (100-119)
       * Use history-based suggest feature.
       * </pre>
       *
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       */
      public Builder clearUseHistorySuggest() {
        bitField1_ = (bitField1_ & ~0x00000020);
        useHistorySuggest_ = true;
        onChanged();
        return this;
      }

      private boolean useDictionarySuggest_ = true;
      /**
       * <pre>
       * Use dictionary-based suggest feature.
       * </pre>
       *
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       */
      public boolean hasUseDictionarySuggest() {
        return ((bitField1_ & 0x00000040) == 0x00000040);
      }
      /**
       * <pre>
       * Use dictionary-based suggest feature.
       * </pre>
       *
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       */
      public boolean getUseDictionarySuggest() {
        return useDictionarySuggest_;
      }
      /**
       * <pre>
       * Use dictionary-based suggest feature.
       * </pre>
       *
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       */
      public Builder setUseDictionarySuggest(boolean value) {
        bitField1_ |= 0x00000040;
        useDictionarySuggest_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use dictionary-based suggest feature.
       * </pre>
       *
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       */
      public Builder clearUseDictionarySuggest() {
        bitField1_ = (bitField1_ & ~0x00000040);
        useDictionarySuggest_ = true;
        onChanged();
        return this;
      }

      private boolean useRealtimeConversion_ = true;
      /**
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       *
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       */
      public boolean hasUseRealtimeConversion() {
        return ((bitField1_ & 0x00000080) == 0x00000080);
      }
      /**
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       *
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       */
      public boolean getUseRealtimeConversion() {
        return useRealtimeConversion_;
      }
      /**
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       *
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       */
      public Builder setUseRealtimeConversion(boolean value) {
        bitField1_ |= 0x00000080;
        useRealtimeConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       *
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       */
      public Builder clearUseRealtimeConversion() {
        bitField1_ = (bitField1_ & ~0x00000080);
        useRealtimeConversion_ = true;
        onChanged();
        return this;
      }

      private int suggestionsSize_ = 3;
      /**
       * <pre>
       * Size of suggestions.
       * </pre>
       *
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       */
      public boolean hasSuggestionsSize() {
        return ((bitField1_ & 0x00000100) == 0x00000100);
      }
      /**
       * <pre>
       * Size of suggestions.
       * </pre>
       *
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       */
      public int getSuggestionsSize() {
        return suggestionsSize_;
      }
      /**
       * <pre>
       * Size of suggestions.
       * </pre>
       *
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       */
      public Builder setSuggestionsSize(int value) {
        bitField1_ |= 0x00000100;
        suggestionsSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Size of suggestions.
       * </pre>
       *
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       */
      public Builder clearSuggestionsSize() {
        bitField1_ = (bitField1_ & ~0x00000100);
        suggestionsSize_ = 3;
        onChanged();
        return this;
      }

      private boolean useModeIndicator_ = true;
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Renderer (120-139)
       * Use mode indicator feature.
       * </pre>
       *
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       */
      public boolean hasUseModeIndicator() {
        return ((bitField1_ & 0x00000200) == 0x00000200);
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Renderer (120-139)
       * Use mode indicator feature.
       * </pre>
       *
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       */
      public boolean getUseModeIndicator() {
        return useModeIndicator_;
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Renderer (120-139)
       * Use mode indicator feature.
       * </pre>
       *
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       */
      public Builder setUseModeIndicator(boolean value) {
        bitField1_ |= 0x00000200;
        useModeIndicator_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       * Renderer (120-139)
       * Use mode indicator feature.
       * </pre>
       *
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       */
      public Builder clearUseModeIndicator() {
        bitField1_ = (bitField1_ & ~0x00000200);
        useModeIndicator_ = true;
        onChanged();
        return this;
      }

      private boolean allowCloudHandwriting_ ;
      /**
       * <pre>
       * Allow the cloud handwriting.  The handwriting UI has to notice
       * user before activating the feature, and set this field to true
       * when the user permit.
       * NOTE: OSS version does not handle this field.
       * </pre>
       *
       * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
       */
      public boolean hasAllowCloudHandwriting() {
        return ((bitField1_ & 0x00000400) == 0x00000400);
      }
      /**
       * <pre>
       * Allow the cloud handwriting.  The handwriting UI has to notice
       * user before activating the feature, and set this field to true
       * when the user permit.
       * NOTE: OSS version does not handle this field.
       * </pre>
       *
       * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
       */
      public boolean getAllowCloudHandwriting() {
        return allowCloudHandwriting_;
      }
      /**
       * <pre>
       * Allow the cloud handwriting.  The handwriting UI has to notice
       * user before activating the feature, and set this field to true
       * when the user permit.
       * NOTE: OSS version does not handle this field.
       * </pre>
       *
       * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
       */
      public Builder setAllowCloudHandwriting(boolean value) {
        bitField1_ |= 0x00000400;
        allowCloudHandwriting_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Allow the cloud handwriting.  The handwriting UI has to notice
       * user before activating the feature, and set this field to true
       * when the user permit.
       * NOTE: OSS version does not handle this field.
       * </pre>
       *
       * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
       */
      public Builder clearAllowCloudHandwriting() {
        bitField1_ = (bitField1_ & ~0x00000400);
        allowCloudHandwriting_ = false;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:mozc.config.Config)
    }

    // @@protoc_insertion_point(class_scope:mozc.config.Config)
    private static final org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Config>
        PARSER = new com.google.protobuf.AbstractParser<Config>() {
      public Config parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Config(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Config> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Config> getParserForType() {
      return PARSER;
    }

    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_config_GeneralConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_config_GeneralConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_config_Config_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_config_Config_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_config_Config_CharacterFormRule_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_config_Config_CharacterFormRule_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_config_Config_InformationListConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_mozc_config_Config_InformationListConfig_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\025protocol/config.proto\022\013mozc.config\"\305\001\n" +
      "\rGeneralConfig\022\031\n\016config_version\030\001 \001(\r:\001" +
      "0\022.\n\035last_modified_product_version\030\002 \001(\t" +
      ":\0070.0.0.0\022\035\n\022last_modified_time\030\003 \001(\004:\0010" +
      "\022\022\n\010platform\030\004 \001(\t:\000\022\023\n\tui_locale\030\005 \001(\t:" +
      "\000\022!\n\022upload_usage_stats\030\006 \001(\010:\005false\"\217\034\n" +
      "\006Config\0222\n\016general_config\030\001 \001(\0132\032.mozc.c" +
      "onfig.GeneralConfig\022\030\n\rverbose_level\030\n \001" +
      "(\005:\0010\022\035\n\016incognito_mode\030\024 \001(\010:\005false\022\033\n\r" +
      "check_default\030\026 \001(\010:\004true\022 \n\021presentatio" +
      "n_mode\030\027 \001(\010:\005false\022@\n\016preedit_method\030( " +
      "\001(\0162!.mozc.config.Config.PreeditMethod:\005" +
      "ROMAN\022?\n\016session_keymap\030) \001(\0162!.mozc.con" +
      "fig.Config.SessionKeymap:\004NONE\022\033\n\023custom" +
      "_keymap_table\030* \001(\014\022\032\n\022custom_roman_tabl" +
      "e\030+ \001(\014\022O\n\022punctuation_method\030- \001(\0162%.mo" +
      "zc.config.Config.PunctuationMethod:\014KUTE" +
      "N_TOUTEN\022R\n\rsymbol_method\030. \001(\0162 .mozc.c" +
      "onfig.Config.SymbolMethod:\031CORNER_BRACKE" +
      "T_MIDDLE_DOT\022b\n\024space_character_form\030/ \001" +
      "(\0162,.mozc.config.Config.FundamentalChara" +
      "cterForm:\026FUNDAMENTAL_INPUT_MODE\0224\n%use_" +
      "keyboard_to_change_preedit_method\0300 \001(\010:" +
      "\005false\022Y\n\026history_learning_level\0302 \001(\0162(" +
      ".mozc.config.Config.HistoryLearningLevel" +
      ":\017DEFAULT_HISTORY\022U\n\022selection_shortcut\030" +
      "4 \001(\0162%.mozc.config.Config.SelectionShor" +
      "tcut:\022SHORTCUT_123456789\022C\n\024character_fo" +
      "rm_rules\0306 \003(\0132%.mozc.config.Config.Char" +
      "acterFormRule\022#\n\025use_auto_ime_turn_off\0308" +
      " \001(\010:\004true\022\"\n\024use_cascading_window\030: \001(\010" +
      ":\004true\022W\n\025shift_key_mode_switch\030; \001(\0162&." +
      "mozc.config.Config.ShiftKeyModeSwitch:\020A" +
      "SCII_INPUT_MODE\022Y\n\025numpad_character_form" +
      "\030< \001(\0162\'.mozc.config.Config.NumpadCharac" +
      "terForm:\021NUMPAD_HALF_WIDTH\022\"\n\023use_auto_c" +
      "onversion\030= \001(\010:\005false\022\037\n\023auto_conversio" +
      "n_key\030> \001(\r:\00213\022J\n\022yen_sign_character\030? " +
      "\001(\0162$.mozc.config.Config.YenSignCharacte" +
      "r:\010YEN_SIGN\022\"\n\023use_japanese_layout\030@ \001(\010" +
      ":\005false\0227\n(use_kana_modifier_insensitive" +
      "_conversion\030A \001(\010:\005false\022$\n\025use_typing_c" +
      "orrection\030B \001(\010:\005false\022!\n\023use_date_conve" +
      "rsion\030P \001(\010:\004true\022)\n\033use_single_kanji_co" +
      "nversion\030Q \001(\010:\004true\022#\n\025use_symbol_conve" +
      "rsion\030R \001(\010:\004true\022#\n\025use_number_conversi" +
      "on\030S \001(\010:\004true\022%\n\027use_emoticon_conversio" +
      "n\030T \001(\010:\004true\022\034\n\016use_calculator\030U \001(\010:\004t" +
      "rue\022!\n\023use_t13n_conversion\030V \001(\010:\004true\022%" +
      "\n\027use_zip_code_conversion\030W \001(\010:\004true\022%\n" +
      "\027use_spelling_correction\030X \001(\010:\004true\022#\n\024" +
      "use_emoji_conversion\030Y \001(\010:\005false\022J\n\027inf" +
      "ormation_list_config\030Z \001(\0132).mozc.config" +
      ".Config.InformationListConfig\022!\n\023use_his" +
      "tory_suggest\030d \001(\010:\004true\022$\n\026use_dictiona" +
      "ry_suggest\030e \001(\010:\004true\022%\n\027use_realtime_c" +
      "onversion\030f \001(\010:\004true\022\033\n\020suggestions_siz" +
      "e\030n \001(\r:\0013\022 \n\022use_mode_indicator\030x \001(\010:\004" +
      "true\022\'\n\027allow_cloud_handwriting\030\255\002 \001(\010:\005" +
      "false\032\303\001\n\021CharacterFormRule\022\r\n\005group\030\001 \001" +
      "(\t\022M\n\026preedit_character_form\030\002 \001(\0162!.moz" +
      "c.config.Config.CharacterForm:\nFULL_WIDT" +
      "H\022P\n\031conversion_character_form\030\003 \001(\0162!.m" +
      "ozc.config.Config.CharacterForm:\nFULL_WI" +
      "DTH\032M\n\025InformationListConfig\022(\n\032use_loca" +
      "l_usage_dictionary\030\001 \001(\010:\004trueJ\004\010\002\020\003J\004\010\n" +
      "\020\013\"$\n\rPreeditMethod\022\t\n\005ROMAN\020\000\022\010\n\004KANA\020\001" +
      "\"j\n\rSessionKeymap\022\021\n\004NONE\020\377\377\377\377\377\377\377\377\377\001\022\n\n\006" +
      "CUSTOM\020\000\022\010\n\004ATOK\020\001\022\t\n\005MSIME\020\002\022\013\n\007KOTOERI" +
      "\020\003\022\n\n\006MOBILE\020\004\022\014\n\010CHROMEOS\020\005\"[\n\021Punctuat" +
      "ionMethod\022\020\n\014KUTEN_TOUTEN\020\000\022\020\n\014COMMA_PER" +
      "IOD\020\001\022\020\n\014KUTEN_PERIOD\020\002\022\020\n\014COMMA_TOUTEN\020" +
      "\003\"\200\001\n\014SymbolMethod\022\035\n\031CORNER_BRACKET_MID" +
      "DLE_DOT\020\000\022\030\n\024SQUARE_BRACKET_SLASH\020\001\022\030\n\024C" +
      "ORNER_BRACKET_SLASH\020\002\022\035\n\031SQUARE_BRACKET_" +
      "MIDDLE_DOT\020\003\"n\n\030FundamentalCharacterForm" +
      "\022\032\n\026FUNDAMENTAL_INPUT_MODE\020\000\022\032\n\026FUNDAMEN" +
      "TAL_FULL_WIDTH\020\001\022\032\n\026FUNDAMENTAL_HALF_WID" +
      "TH\020\002\"J\n\024HistoryLearningLevel\022\023\n\017DEFAULT_" +
      "HISTORY\020\000\022\r\n\tREAD_ONLY\020\001\022\016\n\nNO_HISTORY\020\002" +
      "\"T\n\021SelectionShortcut\022\017\n\013NO_SHORTCUT\020\000\022\026" +
      "\n\022SHORTCUT_123456789\020\001\022\026\n\022SHORTCUT_ASDFG" +
      "HJKL\020\002\"Q\n\rCharacterForm\022\016\n\nHALF_WIDTH\020\000\022" +
      "\016\n\nFULL_WIDTH\020\001\022\r\n\tLAST_FORM\020\002\022\021\n\rNO_CON" +
      "VERSION\020\003\"L\n\022ShiftKeyModeSwitch\022\007\n\003OFF\020\000" +
      "\022\024\n\020ASCII_INPUT_MODE\020\001\022\027\n\023KATAKANA_INPUT" +
      "_MODE\020\002\"s\n\023NumpadCharacterForm\022\025\n\021NUMPAD" +
      "_INPUT_MODE\020\000\022\025\n\021NUMPAD_FULL_WIDTH\020\001\022\025\n\021" +
      "NUMPAD_HALF_WIDTH\020\002\022\027\n\023NUMPAD_DIRECT_INP" +
      "UT\020\003\"\254\001\n\021AutoConversionKey\022\027\n\023AUTO_CONVE" +
      "RSION_OFF\020\000\022\031\n\025AUTO_CONVERSION_KUTEN\020\001\022\032" +
      "\n\026AUTO_CONVERSION_TOUTEN\020\002\022!\n\035AUTO_CONVE" +
      "RSION_QUESTION_MARK\020\004\022$\n AUTO_CONVERSION" +
      "_EXCLAMATION_MARK\020\010\"/\n\020YenSignCharacter\022" +
      "\014\n\010YEN_SIGN\020\000\022\r\n\tBACKSLASH\020\001J\004\010\002\020\nJ\004\010\013\020\014" +
      "J\004\010\025\020\026J\006\010\254\002\020\255\002J\006\010\344\007\020\345\007J\006\010\346\007\020\347\007J\006\010\347\007\020\350\007B=" +
      "\n.org.mozc.android.inputmethod.japanese." +
      "protobufB\013ProtoConfig"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        }, assigner);
    internal_static_mozc_config_GeneralConfig_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_mozc_config_GeneralConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_config_GeneralConfig_descriptor,
        new java.lang.String[] { "ConfigVersion", "LastModifiedProductVersion", "LastModifiedTime", "Platform", "UiLocale", "UploadUsageStats", });
    internal_static_mozc_config_Config_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_mozc_config_Config_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_config_Config_descriptor,
        new java.lang.String[] { "GeneralConfig", "VerboseLevel", "IncognitoMode", "CheckDefault", "PresentationMode", "PreeditMethod", "SessionKeymap", "CustomKeymapTable", "CustomRomanTable", "PunctuationMethod", "SymbolMethod", "SpaceCharacterForm", "UseKeyboardToChangePreeditMethod", "HistoryLearningLevel", "SelectionShortcut", "CharacterFormRules", "UseAutoImeTurnOff", "UseCascadingWindow", "ShiftKeyModeSwitch", "NumpadCharacterForm", "UseAutoConversion", "AutoConversionKey", "YenSignCharacter", "UseJapaneseLayout", "UseKanaModifierInsensitiveConversion", "UseTypingCorrection", "UseDateConversion", "UseSingleKanjiConversion", "UseSymbolConversion", "UseNumberConversion", "UseEmoticonConversion", "UseCalculator", "UseT13NConversion", "UseZipCodeConversion", "UseSpellingCorrection", "UseEmojiConversion", "InformationListConfig", "UseHistorySuggest", "UseDictionarySuggest", "UseRealtimeConversion", "SuggestionsSize", "UseModeIndicator", "AllowCloudHandwriting", });
    internal_static_mozc_config_Config_CharacterFormRule_descriptor =
      internal_static_mozc_config_Config_descriptor.getNestedTypes().get(0);
    internal_static_mozc_config_Config_CharacterFormRule_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_config_Config_CharacterFormRule_descriptor,
        new java.lang.String[] { "Group", "PreeditCharacterForm", "ConversionCharacterForm", });
    internal_static_mozc_config_Config_InformationListConfig_descriptor =
      internal_static_mozc_config_Config_descriptor.getNestedTypes().get(1);
    internal_static_mozc_config_Config_InformationListConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_mozc_config_Config_InformationListConfig_descriptor,
        new java.lang.String[] { "UseLocalUsageDictionary", });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
